{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spring Security Reference Project","text":"<p>Welcome to the Spring Security Reference Project - a comprehensive educational resource demonstrating advanced Spring Security authentication and authorization patterns.</p> <p> View License</p>"},{"location":"#project-overview","title":"\ud83c\udfaf Project Overview","text":"<p>This project serves as a living reference for Spring Security implementations, featuring:</p> <ul> <li>Multiple Authentication Methods: JDBC, LDAP, OAuth2/OIDC</li> <li>Comprehensive Logging: Educational tracing of all security flows</li> <li>Real-world Patterns: Production-ready security configurations  </li> <li>Testing Examples: Complete API testing suite</li> <li>Modular Architecture: Independent, reusable authentication modules</li> </ul>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TD\n    A[rest-api] --&gt; B[common-security]\n    A --&gt; C[common-auth]\n    A --&gt; D[jdbc-auth]\n    A --&gt; E[ldap-auth]\n    A --&gt; F[oauth2-auth]\n    A --&gt; G[authorization-service]\n\n    B --&gt; C\n    D --&gt; H[(Database)]\n    E --&gt; I[LDAP Directory]\n    F --&gt; J[OAuth2 Providers]</code></pre>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17+</li> <li>Maven 3.6+</li> <li>Your favorite IDE</li> </ul>"},{"location":"#run-the-application","title":"Run the Application","text":"<pre><code>git clone &lt;repository-url&gt;\ncd spring-security-reference\nmvn clean install\nmvn spring-boot:run -pl rest-api\n</code></pre>"},{"location":"#test-authentication","title":"Test Authentication","text":"<pre><code># Test public endpoint\ncurl http://localhost:8080/api/public/hello\n\n# Get JWT token\ncurl -X POST http://localhost:8080/api/auth/login \\\n  -d \"username=admin&amp;password=password\"\n\n# Use JWT token\ncurl -H \"Authorization: Bearer &lt;token&gt;\" \\\n  http://localhost:8080/api/admin/secure\n</code></pre>"},{"location":"#learning-path","title":"\ud83d\udcda Learning Path","text":"<ol> <li>Getting Started - Understand the project structure</li> <li>Authentication Methods - Explore different auth strategies</li> <li>Security Configuration - Learn security setup patterns</li> <li>API Reference - Test endpoints and flows</li> <li>Examples &amp; Tutorials - Practice with real scenarios</li> </ol>"},{"location":"#modules","title":"\ud83d\udd27 Modules","text":"Module Description Purpose rest-api REST endpoints and main application Entry point with secured endpoints common-auth Shared authentication utilities JWT, session, and base auth logic common-security Security configuration Filters, interceptors, and config jdbc-auth Database authentication JDBC-based user authentication ldap-auth Directory authentication LDAP/AD integration patterns oauth2-auth OAuth2/OIDC authentication Social login and identity providers authorization-service Role &amp; permission management Authorization logic and rules"},{"location":"#key-features","title":"\ud83d\udd0d Key Features","text":""},{"location":"#educational-logging","title":"Educational Logging","text":"<p>Every security operation is logged with educational annotations:</p> <pre><code>logger.info(\"\ud83d\udd10 [JDBC-AUTH] Creating BCrypt password encoder for database users\");\nlogger.debug(\"\ud83d\udcda [LEARNING] BCrypt adds salt and hashing for secure password storage\");\n</code></pre>"},{"location":"#multiple-authentication-flows","title":"Multiple Authentication Flows","text":"<ul> <li>Session-based: Traditional form login with sessions</li> <li>JWT-based: Stateless token authentication  </li> <li>OAuth2/OIDC: Social login integration</li> <li>Database: JDBC user store authentication</li> <li>Directory: LDAP/Active Directory integration</li> </ul>"},{"location":"#comprehensive-testing","title":"Comprehensive Testing","text":"<ul> <li>HTTP test files for all endpoints</li> <li>Authentication flow testing</li> <li>Role-based access control validation</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>This is an educational project designed to demonstrate Spring Security patterns. Contributions that enhance the learning experience are welcome!</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#support","title":"\ud83c\udd98 Support","text":"<ul> <li>\ud83d\udcd6 Documentation: Browse this site for comprehensive guides</li> <li>\ud83d\udc1b Issues: Report bugs or request features on GitHub</li> <li>\ud83d\udcac Discussions: Join community discussions for help</li> </ul> <p>Happy Learning! \ud83c\udf93</p> <p>This project is designed for educational purposes to help developers understand Spring Security concepts through practical, well-documented examples.</p>"},{"location":"#mkdocs-documentation-setup","title":"MkDocs Documentation Setup","text":"<p>This directory contains the MkDocs configuration and documentation source files for the Spring Security Reference Project.</p>"},{"location":"#quick-start_1","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#1-install-mkdocs","title":"1. Install MkDocs","text":"<pre><code># Install Python dependencies\npip install -r requirements.txt\n\n# Or install individually\npip install mkdocs-material\n</code></pre>"},{"location":"#2-serve-documentation-locally","title":"2. Serve Documentation Locally","text":"<pre><code># Start development server\npython -m mkdocs serve\n\n# Open browser to http://localhost:8000\n</code></pre>"},{"location":"#3-build-static-site","title":"3. Build Static Site","text":"<pre><code># Build static site\npython -m mkdocs build\n\n# Output will be in site/ directory\n</code></pre>"},{"location":"#customization","title":"\ud83c\udfa8 Customization","text":""},{"location":"#theme-configuration","title":"Theme Configuration","text":"<p>The documentation uses Material for MkDocs with custom colors and features:</p> <ul> <li>Primary Color: Green (Spring theme)</li> <li>Accent Color: Teal</li> <li>Dark/Light Mode: Auto-switching based on system preference</li> <li>Features: Navigation tabs, search, code copying, syntax highlighting</li> </ul>"},{"location":"#adding-content","title":"Adding Content","text":"<ol> <li>Create new markdown files in appropriate directories</li> <li>Update navigation in <code>mkdocs.yml</code></li> <li>Use Material extensions for enhanced formatting</li> <li>Include diagrams with Mermaid syntax</li> </ol>"},{"location":"#markdown-extensions","title":"Markdown Extensions","text":"<p>Available extensions include:</p> <ul> <li>Code highlighting with syntax highlighting</li> <li>Admonitions for notes, warnings, tips</li> <li>Mermaid diagrams for flowcharts and sequences</li> <li>Tabbed content for organized information</li> <li>Task lists with checkboxes</li> <li>Mathematical expressions with MathJax</li> </ul>"},{"location":"#deployment-options","title":"\ud83d\ude80 Deployment Options","text":""},{"location":"#github-pages","title":"GitHub Pages","text":"<ol> <li>Create <code>.github/workflows/docs.yml</code>:</li> </ol> <pre><code>name: Deploy Documentation\non:\n  push:\n    branches: [ main ]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: actions/setup-python@v4\n      with:\n        python-version: 3.x\n    - run: pip install -r requirements.txt\n    - run: python -m mkdocs gh-deploy --force\n</code></pre> <ol> <li>Enable GitHub Pages in repository settings</li> <li>Set source to <code>gh-pages</code> branch</li> </ol>"},{"location":"#development","title":"\ud83d\udd27 Development","text":""},{"location":"#live-reloading","title":"Live Reloading","text":"<p>The development server automatically reloads when files change:</p> <pre><code>python -m mkdocs serve --dev-addr=0.0.0.0:8000\n</code></pre>"},{"location":"#validation","title":"Validation","text":"<p>Check for broken links and validate structure:</p> <pre><code>python -m mkdocs build --strict\n</code></pre>"},{"location":"#tips","title":"\ud83d\udca1 Tips","text":"<ul> <li>Use emoji sparingly but consistently for visual cues</li> <li>Include diagrams for complex authentication flows</li> <li>Provide complete examples with expected outputs</li> <li>Cross-link sections to improve navigation</li> <li>Keep content up-to-date with code changes</li> </ul>"},{"location":"#the-magic-of-mkdocs-gh-deploy","title":"The Magic of mkdocs gh-deploy:","text":"<p>First, <code>mkdocs</code> builds your static website from your Markdown files in the docs directory, creating all the necessary HTML, CSS, and JavaScript files.</p> <p>Second, it automatically commits and pushes this newly built static site to a branch named <code>gh-pages</code> in your repository. The <code>--force</code> flag ensures it overwrites the previous content. In summary:</p> <p>The <code>gh-pages</code> branch is a special branch that only contains the compiled, ready-to-view website. Your source code (the Markdown files) lives in the main branch. The GitHub Action acts as a bridge, automatically building the site from main and publishing the result to gh-pages whenever you update main</p>"},{"location":"api/","title":"API Reference","text":"<p>Comprehensive REST API documentation for the Spring Security Reference project. This section covers all available endpoints, authentication flows, and integration patterns.</p>"},{"location":"api/#api-architecture-overview","title":"\ud83c\udf10 API Architecture Overview","text":"<pre><code>graph TD\n    A[Client Request] --&gt; B{Authentication Required?}\n    B --&gt;|No| C[Public Endpoints]\n    B --&gt;|Yes| D[Authentication Check]\n\n    D --&gt; E{Auth Method}\n    E --&gt;|JWT Token| F[JWT Filter]\n    E --&gt;|Basic Auth| G[HTTP Basic]\n    E --&gt;|OAuth2| H[OAuth2 Filter]\n    E --&gt;|Session| I[Session Auth]\n\n    F --&gt; J[Authorization Check]\n    G --&gt; J\n    H --&gt; J\n    I --&gt; J\n\n    J --&gt; K{Role/Permission Check}\n    K --&gt;|\u2705 Authorized| L[Controller Handler]\n    K --&gt;|\u274c Forbidden| M[403 Access Denied]\n\n    C --&gt; L\n    L --&gt; N[Business Logic]\n    N --&gt; O[JSON Response]\n\n    D --&gt;|\u274c Invalid| P[401 Unauthorized]\n\n    style A fill:#e1f5fe\n    style F fill:#c8e6c9\n    style G fill:#c8e6c9\n    style H fill:#c8e6c9\n    style I fill:#c8e6c9\n    style L fill:#fff3e0\n    style O fill:#e8f5e8</code></pre>"},{"location":"api/#api-categories","title":"\ud83d\udcca API Categories","text":""},{"location":"api/#public-endpoints","title":"\ud83d\udd13 Public Endpoints","text":"<p>No authentication required - accessible to all clients.</p>"},{"location":"api/#authenticated-endpoints","title":"\ud83d\udd10 Authenticated Endpoints","text":"<p>Require valid authentication tokens or credentials.</p>"},{"location":"api/#role-based-endpoints","title":"\ud83d\udc65 Role-Based Endpoints","text":"<p>Require specific roles (<code>ROLE_ADMIN</code>, <code>ROLE_USER</code>) for access.</p>"},{"location":"api/#method-specific-endpoints","title":"\ud83c\udfaf Method-Specific Endpoints","text":"<p>Demonstrate different authentication methods (JWT, JDBC, LDAP, OAuth2).</p>"},{"location":"api/#quick-start","title":"\ud83c\udfaf Quick Start","text":""},{"location":"api/#1-start-the-application","title":"1. Start the Application","text":"<pre><code># Run with default profile (supports all auth methods)\nmvn spring-boot:run\n\n# Or run with specific profile\nmvn spring-boot:run -Dspring-boot.run.profiles=jwt\n</code></pre>"},{"location":"api/#2-test-public-endpoint","title":"2. Test Public Endpoint","text":"<pre><code>curl http://localhost:8080/api/public/hello\n</code></pre>"},{"location":"api/#3-get-jwt-token","title":"3. Get JWT Token","text":"<pre><code>curl -X POST http://localhost:8080/api/auth/login \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=admin&amp;password=password\"\n</code></pre>"},{"location":"api/#4-access-protected-endpoint","title":"4. Access Protected Endpoint","text":"<pre><code>curl -H \"Authorization: Bearer YOUR_JWT_TOKEN\" \\\n  http://localhost:8080/api/admin/secure\n</code></pre>"},{"location":"api/#available-endpoints","title":"\ud83d\udccb Available Endpoints","text":"Category Endpoint Method Auth Required Role Required Public <code>/api/public/hello</code> GET \u274c - Auth <code>/api/auth/login</code> POST \u274c - Auth <code>/api/auth/info</code> GET \u2705 Any Admin <code>/api/admin/secure</code> GET \u2705 <code>ROLE_ADMIN</code> User <code>/api/user/secure</code> GET \u2705 <code>ROLE_USER</code>, <code>ROLE_ADMIN</code> JDBC <code>/api/jdbc/users</code> GET \u2705 Any (Basic Auth) LDAP <code>/api/ldap/users</code> GET \u2705 Any (Basic Auth) OAuth2 <code>/api/oauth2/profile</code> GET \u2705 OAuth2 User"},{"location":"api/#authentication-methods","title":"\ud83d\udd10 Authentication Methods","text":""},{"location":"api/#jwt-token-authentication","title":"JWT Token Authentication","text":"<pre><code>Authorization: Bearer eyJhbGciOiJIUzUxMiJ9...\n</code></pre>"},{"location":"api/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<pre><code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n</code></pre>"},{"location":"api/#oauth2-authentication","title":"OAuth2 Authentication","text":"<p>Redirect-based OAuth2 flow with provider integration.</p>"},{"location":"api/#session-based-authentication","title":"Session-Based Authentication","text":"<p>Traditional session cookies with CSRF protection.</p>"},{"location":"api/#learning-path","title":"\ud83c\udf93 Learning Path","text":""},{"location":"api/#beginner","title":"Beginner","text":"<ol> <li>REST Endpoints \u2192 - Explore all available API endpoints</li> <li>Authentication Flow \u2192 - Understand authentication patterns</li> <li>Error Handling \u2192 - Learn about API error responses</li> </ol>"},{"location":"api/#advanced","title":"Advanced","text":"<ul> <li>Security Configuration \u2192 - Deep dive into security setup</li> <li>Authentication Methods \u2192 - Multiple auth strategies</li> <li>Testing \u2192 - API testing patterns</li> </ul>"},{"location":"api/#development-tools","title":"\ud83d\udee0\ufe0f Development Tools","text":""},{"location":"api/#postman-collection","title":"Postman Collection","text":"<pre><code># Import the provided collection\nSpring-Security-Reference-APIs.postman_collection.json\n</code></pre>"},{"location":"api/#vs-code-rest-client","title":"VS Code REST Client","text":"<pre><code># Use the provided .http file\napi-testing.http\n</code></pre>"},{"location":"api/#curl-examples","title":"cURL Examples","text":"<p>Every endpoint includes ready-to-use cURL commands.</p>"},{"location":"api/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>REST Endpoints \u2192 - Complete endpoint reference</li> <li>Authentication Flow \u2192 - Authentication sequence diagrams  </li> <li>Error Handling \u2192 - Error response patterns</li> <li>Security Configuration \u2192 - Security implementation details</li> </ul> <p>\ud83c\udf10 The API Reference provides complete documentation for integrating with our Spring Security demonstration endpoints. Each section includes practical examples and educational insights.</p>"},{"location":"api/auth-flow/","title":"Authentication Flow","text":"<p>Detailed authentication flow patterns and sequences for all supported authentication methods in the Spring Security Reference API.</p>"},{"location":"api/auth-flow/#authentication-architecture","title":"\ud83d\udd04 Authentication Architecture","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant F as Security Filter\n    participant P as Auth Provider\n    participant S as Security Context\n    participant A as API Controller\n\n    C-&gt;&gt;F: HTTP Request with Credentials\n    F-&gt;&gt;F: Extract Authentication Details\n    F-&gt;&gt;P: Authenticate Request\n    P-&gt;&gt;P: Validate Credentials\n    P--&gt;&gt;F: Authentication Result\n    F-&gt;&gt;S: Set Security Context\n    F-&gt;&gt;A: Forward Request\n    A-&gt;&gt;A: Check Authorization\n    A--&gt;&gt;C: JSON Response</code></pre>"},{"location":"api/auth-flow/#authentication-method-flows","title":"\ud83c\udfaf Authentication Method Flows","text":""},{"location":"api/auth-flow/#1-jwt-token-authentication","title":"1. JWT Token Authentication","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant L as Login Endpoint\n    participant J as JWT Util\n    participant F as JWT Filter\n    participant A as API Endpoint\n\n    Note over C,A: Step 1: Obtain JWT Token\n    C-&gt;&gt;L: POST /api/auth/login&lt;br/&gt;username=admin&amp;password=password\n    L-&gt;&gt;J: Generate JWT Token\n    J-&gt;&gt;J: Create Claims (username, role)\n    J-&gt;&gt;J: Sign with Secret Key\n    J--&gt;&gt;L: JWT Token\n    L--&gt;&gt;C: {\"token\": \"eyJhbGci...\"}\n\n    Note over C,A: Step 2: Use JWT Token\n    C-&gt;&gt;F: GET /api/admin/secure&lt;br/&gt;Authorization: Bearer eyJhbGci...\n    F-&gt;&gt;F: Extract Token from Header\n    F-&gt;&gt;J: Validate JWT Token\n    J-&gt;&gt;J: Verify Signature &amp; Expiry\n    J--&gt;&gt;F: Claims {username, role}\n    F-&gt;&gt;F: Create Authentication Object\n    F-&gt;&gt;A: Forward Request\n    A-&gt;&gt;A: Check Role Authorization\n    A--&gt;&gt;C: Secured Response</code></pre> <p>\ud83c\udf93 JWT Flow Learning Points: - Stateless Authentication: No server-side session storage - Claims-Based: User identity and roles encoded in token - Self-Contained: Token includes all necessary information - Expiry Handling: Tokens have built-in expiration</p> <p>\ud83d\udccb JWT Token Structure: <pre><code>{\n  \"header\": {\n    \"alg\": \"HS512\",\n    \"typ\": \"JWT\"\n  },\n  \"payload\": {\n    \"sub\": \"admin\",\n    \"role\": \"ROLE_ADMIN\", \n    \"iat\": 1694520000,\n    \"exp\": 1694606400\n  },\n  \"signature\": \"HMACSHA512(base64UrlEncode(header) + \\\".\\\" + base64UrlEncode(payload), secret)\"\n}\n</code></pre></p>"},{"location":"api/auth-flow/#2-http-basic-authentication","title":"2. HTTP Basic Authentication","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant F as Basic Auth Filter\n    participant P as DaoAuthenticationProvider\n    participant U as UserDetailsService\n    participant A as API Endpoint\n\n    C-&gt;&gt;F: GET /api/jdbc/users&lt;br/&gt;Authorization: Basic dXNlcjpwYXNz\n    F-&gt;&gt;F: Decode Base64 Credentials\n    F-&gt;&gt;F: Extract Username &amp; Password\n    F-&gt;&gt;P: Authenticate(username, password)\n    P-&gt;&gt;U: Load User Details\n    U-&gt;&gt;U: Query Database/LDAP\n    U--&gt;&gt;P: UserDetails with Authorities\n    P-&gt;&gt;P: Verify Password\n    P--&gt;&gt;F: Authentication Success\n    F-&gt;&gt;F: Set Security Context\n    F-&gt;&gt;A: Forward Request\n    A--&gt;&gt;C: Secured Response</code></pre> <p>\ud83c\udf93 Basic Auth Flow Learning Points: - Request-Based: Credentials sent with every request - Base64 Encoding: Username:password encoded (not encrypted) - Database/LDAP Integration: User details loaded from data source - Role Assignment: Authorities loaded with user details</p> <p>\ud83d\udccb Basic Auth Header Format: <pre><code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n# Base64 encoded \"username:password\"\n</code></pre></p>"},{"location":"api/auth-flow/#3-oauth2-authentication-flow","title":"3. OAuth2 Authentication Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client/Browser\n    participant A as Application\n    participant P as OAuth2 Provider\n    participant F as OAuth2 Filter\n    participant E as API Endpoint\n\n    Note over C,E: OAuth2 Authorization Code Flow\n    C-&gt;&gt;A: Access Protected Resource\n    A--&gt;&gt;C: Redirect to OAuth2 Provider\n    C-&gt;&gt;P: Login &amp; Grant Permission\n    P--&gt;&gt;C: Redirect with Authorization Code\n    C-&gt;&gt;A: Authorization Code\n    A-&gt;&gt;P: Exchange Code for Access Token\n    P--&gt;&gt;A: Access Token &amp; ID Token\n    A-&gt;&gt;A: Create OAuth2User Principal\n    A-&gt;&gt;A: Set Security Context\n\n    Note over C,E: Subsequent API Calls\n    C-&gt;&gt;F: GET /api/oauth2/profile&lt;br/&gt;Cookie: JSESSIONID=...\n    F-&gt;&gt;F: Load Authentication from Session\n    F-&gt;&gt;E: Forward Request\n    E-&gt;&gt;E: Extract OAuth2User Attributes\n    E--&gt;&gt;C: Profile Response with OAuth2 Data</code></pre> <p>\ud83c\udf93 OAuth2 Flow Learning Points: - Authorization Code Flow: Most secure OAuth2 flow - Provider Integration: Google, GitHub, Facebook support - Session-Based: Post-authentication uses session cookies - Attribute Mapping: Provider-specific user attributes</p>"},{"location":"api/auth-flow/#4-session-based-authentication","title":"4. Session-Based Authentication","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant L as Login Form\n    participant P as Auth Provider\n    participant S as Session Manager\n    participant F as Session Filter\n    participant A as API Endpoint\n\n    Note over C,A: Initial Login\n    C-&gt;&gt;L: POST /login (username, password)\n    L-&gt;&gt;P: Authenticate Credentials\n    P--&gt;&gt;L: Authentication Success\n    L-&gt;&gt;S: Create HTTP Session\n    S--&gt;&gt;C: Set-Cookie: JSESSIONID=ABC123\n\n    Note over C,A: Subsequent Requests\n    C-&gt;&gt;F: GET /api/user/secure&lt;br/&gt;Cookie: JSESSIONID=ABC123\n    F-&gt;&gt;S: Retrieve Authentication from Session\n    S--&gt;&gt;F: Authentication Object\n    F-&gt;&gt;A: Forward Request with Authentication\n    A--&gt;&gt;C: Secured Response</code></pre> <p>\ud83c\udf93 Session Flow Learning Points: - Server-Side State: Authentication stored in server session - Cookie-Based: Session ID transmitted via HTTP cookies - CSRF Protection: Cross-Site Request Forgery mitigation - Session Lifecycle: Login, timeout, logout management</p>"},{"location":"api/auth-flow/#authentication-method-detection","title":"\ud83d\udd0d Authentication Method Detection","text":"<p>The API automatically detects and reports the authentication method used:</p> <pre><code>public String determineAuthType(Authentication auth) {\n    String principalType = auth.getPrincipal().getClass().getSimpleName();\n\n    if (principalType.contains(\"OAuth2\")) {\n        return \"OAuth2\";\n    } else if (principalType.contains(\"Ldap\")) {\n        return \"LDAP\";\n    } else if (principalType.contains(\"User\")) {\n        return \"JDBC/Database\";\n    } else if (auth.getDetails().toString().contains(\"JWT\")) {\n        return \"JWT\";\n    } else {\n        return \"Custom/Session\";\n    }\n}\n</code></pre>"},{"location":"api/auth-flow/#security-filter-chain-order","title":"\ud83d\udee1\ufe0f Security Filter Chain Order","text":"<pre><code>graph TD\n    A[HTTP Request] --&gt; B[CSRF Filter]\n    B --&gt; C[Logout Filter]\n    C --&gt; D[OAuth2 Authorization Filter]\n    D --&gt; E[OAuth2 Login Filter]\n    E --&gt; F[JWT Authentication Filter]\n    F --&gt; G[Basic Authentication Filter]\n    G --&gt; H[Form Login Filter]\n    H --&gt; I[Session Management Filter]\n    I --&gt; J[Authorization Filter]\n    J --&gt; K[Controller]\n\n    style A fill:#e1f5fe\n    style F fill:#c8e6c9\n    style G fill:#c8e6c9\n    style J fill:#ffecb3\n    style K fill:#fff3e0</code></pre> <p>\ud83c\udf93 Filter Chain Learning Points: - Order Matters: Filters execute in specific sequence - First Match Wins: First successful authentication is used - Skip Logic: Authenticated requests skip unnecessary filters - Exception Handling: Authentication failures handled gracefully</p>"},{"location":"api/auth-flow/#authorization-decision-flow","title":"\ud83d\udd10 Authorization Decision Flow","text":"<pre><code>flowchart TD\n    A[Authenticated Request] --&gt; B{URL Pattern Match}\n\n    B --&gt;|/api/public/**| C[\u2705 Allow - Public Access]\n    B --&gt;|/api/admin/**| D{Has ROLE_ADMIN?}\n    B --&gt;|/api/user/**| E{Has ROLE_USER or ROLE_ADMIN?}\n    B --&gt;|Other patterns| F{Authenticated?}\n\n    D --&gt;|Yes| G[\u2705 Allow - Admin Access]\n    D --&gt;|No| H[\u274c 403 Access Denied]\n\n    E --&gt;|Yes| I[\u2705 Allow - User Access]  \n    E --&gt;|No| H\n\n    F --&gt;|Yes| J[\u2705 Allow - Authenticated Access]\n    F --&gt;|No| K[\u274c 401 Unauthorized]\n\n    style C fill:#c8e6c9\n    style G fill:#c8e6c9\n    style I fill:#c8e6c9\n    style J fill:#c8e6c9\n    style H fill:#ffcdd2\n    style K fill:#ffcdd2</code></pre>"},{"location":"api/auth-flow/#multi-profile-authentication","title":"\ud83d\udcf1 Multi-Profile Authentication","text":"<p>Different Spring profiles enable different authentication methods:</p> Default ProfileJWT ProfileJDBC ProfileLDAP ProfileOAuth2 Profile <p><pre><code># Supports all authentication methods\nspring:\n  profiles:\n    active: default\n</code></pre> Available Methods: JWT, Basic Auth, OAuth2, Session</p> <p><pre><code>spring:\n  profiles:\n    active: jwt\n</code></pre> Primary Method: JWT Token Authentication</p> <p><pre><code>spring:\n  profiles:\n    active: jdbc  \n</code></pre> Primary Method: Database-backed Basic Authentication</p> <p><pre><code>spring:\n  profiles:\n    active: ldap\n</code></pre> Primary Method: LDAP Directory Authentication</p> <p><pre><code>spring:\n  profiles:\n    active: oauth2\n</code></pre> Primary Method: OAuth2/OIDC Authentication</p>"},{"location":"api/auth-flow/#testing-authentication-flows","title":"\ud83e\uddea Testing Authentication Flows","text":""},{"location":"api/auth-flow/#jwt-flow-test","title":"JWT Flow Test","text":"<pre><code>@Test\nvoid jwtAuthenticationFlow() {\n    // Step 1: Get JWT token\n    ResponseEntity&lt;Map&gt; loginResponse = restTemplate.postForEntity(\n        \"/api/auth/login\",\n        createLoginRequest(\"admin\", \"password\"),\n        Map.class\n    );\n\n    String token = (String) loginResponse.getBody().get(\"token\");\n\n    // Step 2: Use JWT token\n    HttpHeaders headers = new HttpHeaders();\n    headers.setBearerAuth(token);\n\n    ResponseEntity&lt;Map&gt; response = restTemplate.exchange(\n        \"/api/admin/secure\",\n        HttpMethod.GET,\n        new HttpEntity&lt;&gt;(headers),\n        Map.class\n    );\n\n    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n}\n</code></pre>"},{"location":"api/auth-flow/#basic-auth-flow-test","title":"Basic Auth Flow Test","text":"<pre><code>@Test\nvoid basicAuthenticationFlow() {\n    HttpHeaders headers = new HttpHeaders();\n    headers.setBasicAuth(\"jdbcadmin\", \"password\");\n\n    ResponseEntity&lt;Map&gt; response = restTemplate.exchange(\n        \"/api/jdbc/users\",\n        HttpMethod.GET,\n        new HttpEntity&lt;&gt;(headers),\n        Map.class\n    );\n\n    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n}\n</code></pre>"},{"location":"api/auth-flow/#performance-considerations","title":"\u26a1 Performance Considerations","text":""},{"location":"api/auth-flow/#authentication-method-performance","title":"Authentication Method Performance","text":"Method Setup Cost Request Cost Scalability Use Case JWT Low Very Low Excellent Stateless APIs Basic Auth Low Medium Good Simple APIs OAuth2 High Low Excellent External identity Session Medium Low Fair Traditional web apps"},{"location":"api/auth-flow/#optimization-tips","title":"Optimization Tips","text":"<ul> <li>JWT: Use short expiry times with refresh tokens</li> <li>Basic Auth: Consider caching user details</li> <li>OAuth2: Implement token refresh logic</li> <li>Session: Configure appropriate session timeout</li> </ul>"},{"location":"api/auth-flow/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Error Handling \u2192 - Authentication and authorization error patterns</li> <li>REST Endpoints \u2192 - Complete endpoint reference</li> <li>Security Configuration \u2192 - Deep dive into security setup</li> <li>Testing Examples \u2192 - Comprehensive testing patterns</li> </ul> <p>\ud83d\udd04 Understanding authentication flows is crucial for implementing secure APIs. Each method has specific use cases, benefits, and implementation patterns that suit different architectural requirements.</p>"},{"location":"api/error-handling/","title":"Error Handling","text":"<p>Comprehensive guide to API error responses, HTTP status codes, and error handling patterns in the Spring Security Reference project.</p>"},{"location":"api/error-handling/#error-response-architecture","title":"\ud83d\udea8 Error Response Architecture","text":"<pre><code>flowchart TD\n    A[API Request] --&gt; B{Authentication Valid?}\n    B --&gt;|No| C[401 Unauthorized]\n    B --&gt;|Yes| D{Authorization Check}\n\n    D --&gt;|Forbidden| E[403 Access Denied]\n    D --&gt;|Allowed| F{Request Valid?}\n\n    F --&gt;|Invalid| G[400 Bad Request]\n    F --&gt;|Valid| H[Controller Processing]\n\n    H --&gt; I{Business Logic}\n    I --&gt;|Error| J[500 Internal Server Error]\n    I --&gt;|Success| K[200/201/204 Success]\n\n    C --&gt; L[Error Response JSON]\n    E --&gt; L\n    G --&gt; L\n    J --&gt; L\n\n    style C fill:#ffcdd2\n    style E fill:#ffcdd2\n    style G fill:#ffcdd2\n    style J fill:#ffcdd2\n    style K fill:#c8e6c9\n    style L fill:#fff3e0</code></pre>"},{"location":"api/error-handling/#http-status-code-reference","title":"\ud83d\udcca HTTP Status Code Reference","text":""},{"location":"api/error-handling/#success-responses-2xx","title":"\ud83d\udfe2 Success Responses (2xx)","text":"Status Code Endpoint Example Description 200 OK <code>GET /api/user/secure</code> Successful GET request 201 Created <code>POST /api/users</code> Resource created successfully 204 No Content <code>DELETE /api/users/123</code> Successful deletion"},{"location":"api/error-handling/#client-error-responses-4xx","title":"\ud83d\udd34 Client Error Responses (4xx)","text":"Status Code Scenario Description 400 Bad Request Invalid request parameters Malformed request data 401 Unauthorized Missing/invalid authentication Authentication required 403 Forbidden Insufficient permissions Authorization denied 404 Not Found Endpoint doesn't exist Resource not found 405 Method Not Allowed Wrong HTTP method Method not supported"},{"location":"api/error-handling/#server-error-responses-5xx","title":"\ud83d\udfe1 Server Error Responses (5xx)","text":"Status Code Scenario Description 500 Internal Server Error Unhandled exception Server-side error 503 Service Unavailable Service temporarily down Maintenance mode"},{"location":"api/error-handling/#authentication-error-responses","title":"\ud83d\udd10 Authentication Error Responses","text":""},{"location":"api/error-handling/#401-unauthorized-missing-authentication","title":"401 Unauthorized - Missing Authentication","text":"ScenarioResponseHeaders <pre><code>GET /api/admin/secure\n# No Authorization header\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 401,\n  \"error\": \"Unauthorized\",\n  \"message\": \"Authentication required\",\n  \"path\": \"/api/admin/secure\"\n}\n</code></pre> <pre><code>HTTP/1.1 401 Unauthorized\nContent-Type: application/json\nWWW-Authenticate: Bearer realm=\"API\"\n</code></pre> <p>\ud83c\udf93 Learning Points: - No valid authentication credentials provided - Client must authenticate before accessing resource - <code>WWW-Authenticate</code> header suggests authentication method</p>"},{"location":"api/error-handling/#401-unauthorized-invalid-jwt-token","title":"401 Unauthorized - Invalid JWT Token","text":"ScenarioResponse <pre><code>GET /api/admin/secure\nAuthorization: Bearer invalid_token_here\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 401,\n  \"error\": \"Unauthorized\",\n  \"message\": \"Invalid or expired JWT token\",\n  \"details\": {\n    \"tokenError\": \"JWT signature does not match locally computed signature\",\n    \"tokenStatus\": \"INVALID_SIGNATURE\"\n  },\n  \"path\": \"/api/admin/secure\"\n}\n</code></pre> <p>\ud83c\udf93 JWT Token Error Types: - Invalid Signature: Token tampered or wrong secret key - Expired Token: Token past expiration time - Malformed Token: Invalid JWT structure - Missing Claims: Required claims not present</p>"},{"location":"api/error-handling/#401-unauthorized-expired-jwt-token","title":"401 Unauthorized - Expired JWT Token","text":"ScenarioResponse <pre><code>GET /api/user/secure\nAuthorization: Bearer eyJhbGci...expired_token\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 401,\n  \"error\": \"Unauthorized\",\n  \"message\": \"JWT token has expired\",\n  \"details\": {\n    \"tokenError\": \"JWT expired at 2024-01-15T09:30:00Z\",\n    \"tokenStatus\": \"EXPIRED\",\n    \"expiredAt\": \"2024-01-15T09:30:00Z\",\n    \"currentTime\": \"2024-01-15T10:30:00Z\"\n  },\n  \"path\": \"/api/user/secure\"\n}\n</code></pre> <p>\ud83d\udd04 Token Refresh Recommendation: <pre><code>{\n  \"error\": \"Token expired\",\n  \"recommendation\": \"Please obtain a new token via POST /api/auth/login\",\n  \"refreshEndpoint\": \"/api/auth/login\"\n}\n</code></pre></p>"},{"location":"api/error-handling/#401-unauthorized-invalid-basic-auth","title":"401 Unauthorized - Invalid Basic Auth","text":"ScenarioResponse <pre><code>GET /api/jdbc/users\nAuthorization: Basic aW52YWxpZDppbnZhbGlk\n# Base64: \"invalid:invalid\"\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 401,\n  \"error\": \"Unauthorized\",\n  \"message\": \"Invalid username or password\",\n  \"details\": {\n    \"authType\": \"Basic Authentication\",\n    \"reason\": \"Bad credentials\"\n  },\n  \"path\": \"/api/jdbc/users\"\n}\n</code></pre>"},{"location":"api/error-handling/#authorization-error-responses","title":"\ud83d\udeab Authorization Error Responses","text":""},{"location":"api/error-handling/#403-forbidden-insufficient-role","title":"403 Forbidden - Insufficient Role","text":"ScenarioResponse <pre><code>GET /api/admin/secure\nAuthorization: Bearer valid_user_token_with_ROLE_USER\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 403,\n  \"error\": \"Access Denied\",\n  \"message\": \"You don't have permission to access this resource\",\n  \"details\": {\n    \"requiredRole\": \"ROLE_ADMIN\",\n    \"userRoles\": [\"ROLE_USER\"],\n    \"resource\": \"/api/admin/secure\",\n    \"action\": \"GET\"\n  },\n  \"path\": \"/api/admin/secure\"\n}\n</code></pre> <p>\ud83c\udf93 Learning Points: - User is authenticated but lacks required permissions - Shows required vs. actual roles for debugging - Different from 401 - authentication was successful</p>"},{"location":"api/error-handling/#403-forbidden-method-security","title":"403 Forbidden - Method Security","text":"ScenarioResponse <pre><code>@PreAuthorize(\"hasRole('ADMIN') and hasPermission(#userId, 'User', 'DELETE')\")\n@DeleteMapping(\"/api/users/{userId}\")\npublic void deleteUser(@PathVariable String userId) {\n    // Method execution\n}\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 403,\n  \"error\": \"Access Denied\",\n  \"message\": \"Method access denied\",\n  \"details\": {\n    \"methodSecurity\": true,\n    \"expression\": \"hasRole('ADMIN') and hasPermission(#userId, 'User', 'DELETE')\",\n    \"evaluationResult\": false,\n    \"failedCondition\": \"hasPermission(#userId, 'User', 'DELETE')\"\n  },\n  \"path\": \"/api/users/123\"\n}\n</code></pre>"},{"location":"api/error-handling/#request-error-responses","title":"\u274c Request Error Responses","text":""},{"location":"api/error-handling/#400-bad-request-invalid-parameters","title":"400 Bad Request - Invalid Parameters","text":"ScenarioResponse <pre><code>POST /api/auth/login\nContent-Type: application/x-www-form-urlencoded\n\nusername=&amp;password=\n# Empty username and password\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 400,\n  \"error\": \"Bad Request\",\n  \"message\": \"Validation failed for request parameters\",\n  \"details\": {\n    \"validationErrors\": [\n      {\n        \"field\": \"username\",\n        \"message\": \"Username is required and cannot be empty\",\n        \"rejectedValue\": \"\"\n      },\n      {\n        \"field\": \"password\", \n        \"message\": \"Password is required and cannot be empty\",\n        \"rejectedValue\": \"\"\n      }\n    ]\n  },\n  \"path\": \"/api/auth/login\"\n}\n</code></pre>"},{"location":"api/error-handling/#404-not-found-endpoint-not-exist","title":"404 Not Found - Endpoint Not Exist","text":"ScenarioResponse <pre><code>GET /api/nonexistent/endpoint\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 404,\n  \"error\": \"Not Found\",\n  \"message\": \"No endpoint found for GET /api/nonexistent/endpoint\",\n  \"path\": \"/api/nonexistent/endpoint\"\n}\n</code></pre>"},{"location":"api/error-handling/#405-method-not-allowed","title":"405 Method Not Allowed","text":"ScenarioResponse <pre><code>PUT /api/public/hello\n# Endpoint only supports GET\n</code></pre> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 405,\n  \"error\": \"Method Not Allowed\",\n  \"message\": \"Request method 'PUT' not supported\",\n  \"details\": {\n    \"requestMethod\": \"PUT\",\n    \"supportedMethods\": [\"GET\"]\n  },\n  \"path\": \"/api/public/hello\"\n}\n</code></pre>"},{"location":"api/error-handling/#custom-error-handler-implementation","title":"\ud83d\udd27 Custom Error Handler Implementation","text":""},{"location":"api/error-handling/#global-exception-handler","title":"Global Exception Handler","text":"<pre><code>@RestControllerAdvice\npublic class ApiExceptionHandler {\n\n    @ExceptionHandler(AccessDeniedException.class)\n    public ResponseEntity&lt;ErrorResponse&gt; handleAccessDenied(\n            AccessDeniedException ex, HttpServletRequest request) {\n\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(Instant.now())\n            .status(HttpStatus.FORBIDDEN.value())\n            .error(\"Access Denied\")\n            .message(\"You don't have permission to access this resource\")\n            .path(request.getRequestURI())\n            .build();\n\n        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);\n    }\n\n    @ExceptionHandler(AuthenticationException.class)\n    public ResponseEntity&lt;ErrorResponse&gt; handleAuthenticationException(\n            AuthenticationException ex, HttpServletRequest request) {\n\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(Instant.now())\n            .status(HttpStatus.UNAUTHORIZED.value())\n            .error(\"Unauthorized\")\n            .message(\"Authentication required\")\n            .path(request.getRequestURI())\n            .build();\n\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);\n    }\n}\n</code></pre>"},{"location":"api/error-handling/#custom-access-denied-handler","title":"Custom Access Denied Handler","text":"<pre><code>@Component\npublic class CustomAccessDeniedHandler implements AccessDeniedHandler {\n\n    @Override\n    public void handle(HttpServletRequest request,\n                       HttpServletResponse response,\n                       AccessDeniedException accessDeniedException) throws IOException {\n\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        response.setContentType(\"application/json\");\n\n        ErrorResponse error = ErrorResponse.builder()\n            .timestamp(Instant.now())\n            .status(403)\n            .error(\"Access Denied\")\n            .message(\"You don't have permission to access this resource\")\n            .path(request.getRequestURI())\n            .details(Map.of(\n                \"user\", request.getRemoteUser(),\n                \"requiredAuthority\", extractRequiredAuthority(request),\n                \"userAuthorities\", getCurrentUserAuthorities()\n            ))\n            .build();\n\n        ObjectMapper mapper = new ObjectMapper();\n        response.getWriter().write(mapper.writeValueAsString(error));\n    }\n}\n</code></pre>"},{"location":"api/error-handling/#client-error-handling-strategies","title":"\ud83d\udcf1 Client Error Handling Strategies","text":""},{"location":"api/error-handling/#javascripttypescript-client","title":"JavaScript/TypeScript Client","text":"<pre><code>const apiClient = {\n    async request(url, options = {}) {\n        const response = await fetch(url, {\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${getJwtToken()}`,\n                ...options.headers\n            }\n        });\n\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new ApiError(errorData);\n        }\n\n        return response.json();\n    }\n};\n\nclass ApiError extends Error {\n    constructor(errorResponse) {\n        super(errorResponse.message);\n        this.status = errorResponse.status;\n        this.error = errorResponse.error;\n        this.details = errorResponse.details;\n        this.path = errorResponse.path;\n        this.timestamp = errorResponse.timestamp;\n    }\n\n    isAuthenticationError() {\n        return this.status === 401;\n    }\n\n    isAuthorizationError() {\n        return this.status === 403;\n    }\n\n    isTokenExpiredError() {\n        return this.status === 401 &amp;&amp; \n               this.details?.tokenStatus === 'EXPIRED';\n    }\n}\n\n// Usage example\ntry {\n    const userData = await apiClient.request('/api/admin/secure');\n    console.log('User data:', userData);\n} catch (error) {\n    if (error instanceof ApiError) {\n        if (error.isTokenExpiredError()) {\n            // Refresh token and retry\n            await refreshAuthToken();\n            return apiClient.request('/api/admin/secure');\n        } else if (error.isAuthenticationError()) {\n            // Redirect to login\n            redirectToLogin();\n        } else if (error.isAuthorizationError()) {\n            // Show access denied message\n            showAccessDeniedMessage();\n        }\n    }\n}\n</code></pre>"},{"location":"api/error-handling/#java-client-resttemplate","title":"Java Client (RestTemplate)","text":"<pre><code>@Service\npublic class ApiClient {\n\n    private final RestTemplate restTemplate;\n\n    public ApiClient(RestTemplate restTemplate) {\n        this.restTemplate = restTemplate;\n\n        // Configure error handling\n        restTemplate.setErrorHandler(new CustomResponseErrorHandler());\n    }\n\n    public &lt;T&gt; T makeRequest(String url, Class&lt;T&gt; responseType) {\n        try {\n            HttpHeaders headers = new HttpHeaders();\n            headers.setBearerAuth(getJwtToken());\n            HttpEntity&lt;?&gt; entity = new HttpEntity&lt;&gt;(headers);\n\n            ResponseEntity&lt;T&gt; response = restTemplate.exchange(\n                url, HttpMethod.GET, entity, responseType);\n\n            return response.getBody();\n\n        } catch (HttpClientErrorException ex) {\n            handleClientError(ex);\n            throw ex;\n        } catch (HttpServerErrorException ex) {\n            handleServerError(ex);\n            throw ex;\n        }\n    }\n\n    private void handleClientError(HttpClientErrorException ex) {\n        if (ex.getStatusCode() == HttpStatus.UNAUTHORIZED) {\n            // Handle authentication error\n            log.warn(\"Authentication failed: {}\", ex.getResponseBodyAsString());\n        } else if (ex.getStatusCode() == HttpStatus.FORBIDDEN) {\n            // Handle authorization error\n            log.warn(\"Access denied: {}\", ex.getResponseBodyAsString());\n        }\n    }\n}\n\nstatic class CustomResponseErrorHandler implements ResponseErrorHandler {\n\n    @Override\n    public boolean hasError(ClientHttpResponse response) throws IOException {\n        return response.getStatusCode().is4xxClientError() || \n               response.getStatusCode().is5xxServerError();\n    }\n\n    @Override\n    public void handleError(ClientHttpResponse response) throws IOException {\n        String body = StreamUtils.copyToString(\n            response.getBody(), StandardCharsets.UTF_8);\n\n        ErrorResponse error = objectMapper.readValue(body, ErrorResponse.class);\n\n        if (response.getStatusCode().is4xxClientError()) {\n            throw new ApiClientException(error);\n        } else {\n            throw new ApiServerException(error);\n        }\n    }\n}\n</code></pre>"},{"location":"api/error-handling/#testing-error-scenarios","title":"\ud83e\uddea Testing Error Scenarios","text":""},{"location":"api/error-handling/#unit-testing-error-responses","title":"Unit Testing Error Responses","text":"<pre><code>@Test\nvoid shouldReturn401WhenNoAuthenticationProvided() throws Exception {\n    mockMvc.perform(get(\"/api/admin/secure\"))\n        .andExpect(status().isUnauthorized())\n        .andExpected(jsonPath(\"$.status\").value(401))\n        .andExpected(jsonPath(\"$.error\").value(\"Unauthorized\"))\n        .andExpect(jsonPath(\"$.message\").value(\"Authentication required\"))\n        .andExpect(jsonPath(\"$.path\").value(\"/api/admin/secure\"));\n}\n\n@Test\nvoid shouldReturn403WhenInsufficientRole() throws Exception {\n    mockMvc.perform(get(\"/api/admin/secure\")\n            .with(jwt().authorities(new SimpleGrantedAuthority(\"ROLE_USER\"))))\n        .andExpect(status().isForbidden())\n        .andExpected(jsonPath(\"$.status\").value(403))\n        .andExpect(jsonPath(\"$.error\").value(\"Access Denied\"));\n}\n\n@Test  \nvoid shouldReturn400WhenInvalidLoginParameters() throws Exception {\n    mockMvc.perform(post(\"/api/auth/login\")\n            .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n            .param(\"username\", \"\")\n            .param(\"password\", \"\"))\n        .andExpect(status().isBadRequest())\n        .andExpected(jsonPath(\"$.status\").value(400))\n        .andExpected(jsonPath(\"$.details.validationErrors\").isArray());\n}\n</code></pre>"},{"location":"api/error-handling/#integration-testing-with-error-scenarios","title":"Integration Testing with Error Scenarios","text":"<pre><code>@Test\nvoid shouldHandleJwtTokenExpiry() {\n    // Create expired JWT token\n    String expiredToken = jwtUtil.generateExpiredToken(\"user\", \"ROLE_USER\");\n\n    // Make request with expired token\n    ResponseEntity&lt;Map&gt; response = restTemplate.exchange(\n        \"/api/user/secure\",\n        HttpMethod.GET,\n        new HttpEntity&lt;&gt;(createAuthHeaders(expiredToken)),\n        Map.class\n    );\n\n    // Verify error response\n    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);\n    assertThat(response.getBody().get(\"error\")).isEqualTo(\"Unauthorized\");\n    assertThat(response.getBody().get(\"details\"))\n        .extracting(\"tokenStatus\")\n        .isEqualTo(\"EXPIRED\");\n}\n</code></pre>"},{"location":"api/error-handling/#error-response-patterns-summary","title":"\ud83d\udcca Error Response Patterns Summary","text":""},{"location":"api/error-handling/#standard-error-response-format","title":"Standard Error Response Format","text":"<pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00.123Z\",\n  \"status\": 403,\n  \"error\": \"Access Denied\",\n  \"message\": \"You don't have permission to access this resource\",\n  \"details\": {\n    \"additional\": \"context-specific information\"\n  },\n  \"path\": \"/api/admin/secure\"\n}\n</code></pre>"},{"location":"api/error-handling/#error-response-fields","title":"Error Response Fields","text":"Field Type Description Required <code>timestamp</code> ISO 8601 When the error occurred \u2705 <code>status</code> Integer HTTP status code \u2705 <code>error</code> String Error category/type \u2705 <code>message</code> String Human-readable description \u2705 <code>details</code> Object Additional error context \u274c <code>path</code> String Request path that caused error \u2705"},{"location":"api/error-handling/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>REST Endpoints \u2192 - Complete endpoint reference</li> <li>Authentication Flow \u2192 - Authentication sequence patterns</li> <li>Security Configuration \u2192 - Security implementation details</li> <li>Testing Examples \u2192 - Comprehensive testing patterns</li> </ul> <p>\ud83d\udea8 Proper error handling improves API usability and debugging. Consistent error response formats help clients handle different error scenarios gracefully and provide better user experiences.</p>"},{"location":"api/rest-endpoints/","title":"REST Endpoints","text":"<p>Complete reference for all REST API endpoints in the Spring Security Reference project. Each endpoint demonstrates different authentication and authorization patterns.</p>"},{"location":"api/rest-endpoints/#public-endpoints","title":"\ud83d\udd13 Public Endpoints","text":""},{"location":"api/rest-endpoints/#get-apipublichello","title":"GET /api/public/hello","text":"<p>Public endpoint requiring no authentication.</p> RequestResponsecURL <pre><code>GET /api/public/hello\nHost: localhost:8080\n</code></pre> <pre><code>\"Hello, world! (public endpoint - no authentication required)\"\n</code></pre> <pre><code>curl http://localhost:8080/api/public/hello\n</code></pre> <p>\ud83c\udf93 Learning Points: - No security constraints applied - Accessible without any credentials - Used for health checks and public information</p>"},{"location":"api/rest-endpoints/#authentication-endpoints","title":"\ud83d\udd10 Authentication Endpoints","text":""},{"location":"api/rest-endpoints/#post-apiauthlogin","title":"POST /api/auth/login","text":"<p>Generate JWT token for API authentication.</p> RequestResponsecURL <pre><code>POST /api/auth/login\nContent-Type: application/x-www-form-urlencoded\n\nusername=admin&amp;password=password\n</code></pre> <pre><code>{\n  \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJST0xFX0FETUlOIiwiaWF0IjoxNjk0NTIwMDAwLCJleHAiOjE2OTQ2MDY0MDB9.signature\",\n  \"username\": \"admin\", \n  \"role\": \"ROLE_ADMIN\",\n  \"message\": \"Login successful - use this JWT token for authenticated requests\",\n  \"usage\": \"Add header: Authorization: Bearer eyJhbGciOiJIUzUxMiJ9...\"\n}\n</code></pre> <pre><code>curl -X POST http://localhost:8080/api/auth/login \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=admin&amp;password=password\"\n</code></pre> <p>\ud83c\udf93 Learning Points: - Generates JWT tokens with user identity and role claims - No authentication required to obtain token - Token expires after 24 hours (configurable) - Role determination based on username pattern</p> <p>\ud83d\udcdd Available Test Users: - <code>admin</code> / <code>password</code> \u2192 <code>ROLE_ADMIN</code> - <code>user</code> / <code>password</code> \u2192 <code>ROLE_USER</code> - <code>jdbcadmin</code> / <code>password</code> \u2192 <code>ROLE_ADMIN</code> - <code>ldapadmin</code> / <code>password</code> \u2192 <code>ROLE_ADMIN</code></p>"},{"location":"api/rest-endpoints/#get-apiauthinfo","title":"GET /api/auth/info","text":"<p>Retrieve current authentication information.</p> RequestResponsecURL <pre><code>GET /api/auth/info\nAuthorization: Bearer eyJhbGciOiJIUzUxMiJ9...\n</code></pre> <pre><code>{\n  \"authenticated\": true,\n  \"username\": \"admin\",\n  \"authorities\": [\n    {\n      \"authority\": \"ROLE_ADMIN\"\n    }\n  ],\n  \"authType\": \"JWT\",\n  \"principalType\": \"UsernamePasswordAuthenticationToken\"\n}\n</code></pre> <pre><code>curl -H \"Authorization: Bearer YOUR_JWT_TOKEN\" \\\n  http://localhost:8080/api/auth/info\n</code></pre> <p>\ud83c\udf93 Learning Points: - Requires valid authentication - Shows current security context details - Identifies authentication method used - Useful for debugging authentication issues</p>"},{"location":"api/rest-endpoints/#admin-endpoints","title":"\ud83d\udc68\u200d\ud83d\udcbc Admin Endpoints","text":""},{"location":"api/rest-endpoints/#get-apiadminsecure","title":"GET /api/admin/secure","text":"<p>Secure endpoint requiring <code>ROLE_ADMIN</code> authority.</p> RequestResponsecURL <pre><code>GET /api/admin/secure\nAuthorization: Bearer eyJhbGciOiJIUzUxMiJ9...\n</code></pre> <pre><code>{\n  \"message\": \"Hello, Admin! (secured endpoint)\",\n  \"user\": \"admin\",\n  \"authorities\": [\n    {\n      \"authority\": \"ROLE_ADMIN\" \n    }\n  ],\n  \"authType\": \"JWT\"\n}\n</code></pre> <pre><code>curl -H \"Authorization: Bearer YOUR_ADMIN_JWT_TOKEN\" \\\n  http://localhost:8080/api/admin/secure\n</code></pre> <p>\ud83c\udf93 Learning Points: - Requires <code>ROLE_ADMIN</code> authority - Returns 403 Forbidden for non-admin users - Supports all authentication methods (JWT, Basic, OAuth2) - Demonstrates role-based access control</p> <p>\u26a0\ufe0f Error Response (403 Forbidden): <pre><code>{\n  \"error\": \"Access Denied\",\n  \"message\": \"You don't have permission to access this resource\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"path\": \"/api/admin/secure\"\n}\n</code></pre></p>"},{"location":"api/rest-endpoints/#user-endpoints","title":"\ud83d\udc64 User Endpoints","text":""},{"location":"api/rest-endpoints/#get-apiusersecure","title":"GET /api/user/secure","text":"<p>Secure endpoint for users with <code>ROLE_USER</code> or <code>ROLE_ADMIN</code>.</p> RequestResponsecURL <pre><code>GET /api/user/secure  \nAuthorization: Bearer eyJhbGciOiJIUzUxMiJ9...\n</code></pre> <pre><code>{\n  \"message\": \"Hello, User! (secured endpoint)\",\n  \"user\": \"user\",\n  \"authorities\": [\n    {\n      \"authority\": \"ROLE_USER\"\n    }\n  ],\n  \"authType\": \"JWT\"\n}\n</code></pre> <pre><code>curl -H \"Authorization: Bearer YOUR_JWT_TOKEN\" \\\n  http://localhost:8080/api/user/secure\n</code></pre> <p>\ud83c\udf93 Learning Points: - Accepts both <code>ROLE_USER</code> and <code>ROLE_ADMIN</code> - Demonstrates role hierarchy (ADMIN &gt; USER) - Multi-role endpoint access pattern - Role-based response customization</p>"},{"location":"api/rest-endpoints/#jdbc-authentication-endpoints","title":"\ud83d\uddc4\ufe0f JDBC Authentication Endpoints","text":""},{"location":"api/rest-endpoints/#get-apijdbcusers","title":"GET /api/jdbc/users","text":"<p>Demonstration endpoint for JDBC database authentication.</p> RequestResponsecURL <pre><code>GET /api/jdbc/users\nAuthorization: Basic amRiY2FkbWluOnBhc3N3b3Jk\n</code></pre> <pre><code>{\n  \"message\": \"JDBC Authentication Demo\",\n  \"user\": \"jdbcadmin\",\n  \"credentials\": {\n    \"jdbcadmin\": \"password (ROLE_ADMIN)\",\n    \"jdbcuser\": \"password (ROLE_USER)\"\n  }\n}\n</code></pre> <pre><code># Using Basic Auth with JDBC credentials\ncurl -H \"Authorization: Basic amRiY2FkbWluOnBhc3N3b3Jk\" \\\n  http://localhost:8080/api/jdbc/users\n\n# Or with username:password\ncurl -u jdbcadmin:password \\\n  http://localhost:8080/api/jdbc/users\n</code></pre> <p>\ud83c\udf93 Learning Points: - Demonstrates HTTP Basic authentication - Uses database-stored user credentials - Profile-specific endpoint (<code>jdbc</code> profile) - Base64 encoded credentials in Authorization header</p> <p>\ud83d\udcdd JDBC Test Credentials: - Username: <code>jdbcadmin</code>, Password: <code>password</code> (ROLE_ADMIN) - Username: <code>jdbcuser</code>, Password: <code>password</code> (ROLE_USER)</p>"},{"location":"api/rest-endpoints/#ldap-authentication-endpoints","title":"\ud83c\udfe2 LDAP Authentication Endpoints","text":""},{"location":"api/rest-endpoints/#get-apildapusers","title":"GET /api/ldap/users","text":"<p>Demonstration endpoint for LDAP directory authentication.</p> RequestResponsecURL <pre><code>GET /api/ldap/users\nAuthorization: Basic bGRhcGFkbWluOnBhc3N3b3Jk\n</code></pre> <pre><code>{\n  \"message\": \"LDAP Authentication Demo\",\n  \"user\": \"ldapadmin\", \n  \"credentials\": {\n    \"ldapadmin\": \"password (ROLE_ADMIN)\",\n    \"ldapuser\": \"password (ROLE_USER)\"\n  }\n}\n</code></pre> <pre><code># Using Basic Auth with LDAP credentials\ncurl -H \"Authorization: Basic bGRhcGFkbWluOnBhc3N3b3Jk\" \\\n  http://localhost:8080/api/ldap/users\n\n# Or with username:password  \ncurl -u ldapadmin:password \\\n  http://localhost:8080/api/ldap/users\n</code></pre> <p>\ud83c\udf93 Learning Points: - Demonstrates LDAP directory integration - Uses embedded LDAP server for testing - Profile-specific endpoint (<code>ldap</code> profile) - Group-based role mapping</p> <p>\ud83d\udcdd LDAP Test Credentials: - Username: <code>ldapadmin</code>, Password: <code>password</code> (ROLE_ADMIN) - Username: <code>ldapuser</code>, Password: <code>password</code> (ROLE_USER)</p>"},{"location":"api/rest-endpoints/#oauth2-authentication-endpoints","title":"\ud83c\udf10 OAuth2 Authentication Endpoints","text":""},{"location":"api/rest-endpoints/#get-apioauth2profile","title":"GET /api/oauth2/profile","text":"<p>User profile endpoint for OAuth2/OIDC authenticated users.</p> OAuth2 User RequestOAuth2 User ResponseNon-OAuth2 User ResponsecURL <pre><code>GET /api/oauth2/profile\nCookie: JSESSIONID=ABC123...\n</code></pre> <pre><code>{\n  \"message\": \"OAuth2 Authentication Demo\",\n  \"user\": \"john.doe@example.com\",\n  \"email\": \"john.doe@example.com\",\n  \"provider\": \"OAuth2\",\n  \"attributes\": {\n    \"sub\": \"12345\",\n    \"name\": \"John Doe\", \n    \"email\": \"john.doe@example.com\",\n    \"picture\": \"https://avatar.url\"\n  }\n}\n</code></pre> <pre><code>{\n  \"message\": \"OAuth2 Authentication Demo\",\n  \"user\": \"admin\",\n  \"authorities\": [\n    {\n      \"authority\": \"ROLE_ADMIN\"\n    }\n  ]\n}\n</code></pre> <pre><code># After OAuth2 login, session cookie is used\ncurl -H \"Cookie: JSESSIONID=YOUR_SESSION_ID\" \\\n  http://localhost:8080/api/oauth2/profile\n</code></pre> <p>\ud83c\udf93 Learning Points: - Handles both OAuth2 and traditional users - Extracts OAuth2 user attributes (email, name, picture) - Session-based authentication post-OAuth2 flow - Provider-specific attribute handling</p> <p>\ud83d\udd27 OAuth2 Configuration: - Supports Google, GitHub, Facebook providers - OIDC (OpenID Connect) compatible - Profile-specific endpoint (<code>oauth2</code> profile)</p>"},{"location":"api/rest-endpoints/#endpoint-summary-matrix","title":"\ud83d\udcca Endpoint Summary Matrix","text":"Endpoint Auth Method Role Required Profile Purpose <code>/api/public/hello</code> None - All Public access demo <code>/api/auth/login</code> None - All JWT token generation <code>/api/auth/info</code> Any Any All Auth debugging <code>/api/admin/secure</code> Any ADMIN All Admin-only access <code>/api/user/secure</code> Any USER/ADMIN All User access demo <code>/api/jdbc/users</code> Basic Auth Any jdbc JDBC auth demo <code>/api/ldap/users</code> Basic Auth Any ldap LDAP auth demo <code>/api/oauth2/profile</code> Session/OAuth2 Any oauth2 OAuth2 profile"},{"location":"api/rest-endpoints/#testing-strategies","title":"\ud83c\udfaf Testing Strategies","text":""},{"location":"api/rest-endpoints/#unit-testing-endpoints","title":"Unit Testing Endpoints","text":"<pre><code>@Test\n@WithMockUser(roles = \"ADMIN\")\nvoid adminEndpointWithAdminRole() throws Exception {\n    mockMvc.perform(get(\"/api/admin/secure\"))\n        .andExpect(status().isOk())\n        .andExpect(jsonPath(\"$.message\").value(\"Hello, Admin! (secured endpoint)\"));\n}\n</code></pre>"},{"location":"api/rest-endpoints/#integration-testing","title":"Integration Testing","text":"<pre><code>@Test\nvoid jwtAuthenticationFlow() {\n    // 1. Login to get JWT token\n    String token = getJwtToken(\"admin\", \"password\");\n\n    // 2. Use token to access secured endpoint\n    given()\n        .header(\"Authorization\", \"Bearer \" + token)\n        .when()\n        .get(\"/api/admin/secure\")\n        .then()\n        .statusCode(200);\n}\n</code></pre>"},{"location":"api/rest-endpoints/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Authentication Flow \u2192 - Understand authentication sequences</li> <li>Error Handling \u2192 - API error response patterns  </li> <li>Security Configuration \u2192 - Security implementation details</li> <li>Testing Examples \u2192 - Comprehensive testing patterns</li> </ul> <p>\ud83d\udccb This reference covers all REST endpoints with practical examples, authentication requirements, and educational insights for learning Spring Security patterns.</p>"},{"location":"api/swagger/","title":"Live API Documentation (Swagger UI)","text":"<p>This page provides a link to the live, interactive API documentation generated by Swagger.</p> <p>Note: To access the Swagger UI, the Spring Boot application must be running.</p>"},{"location":"api/swagger/#accessing-swagger-ui","title":"Accessing Swagger UI","text":"<ol> <li> <p>Run the application:     <pre><code>mvn spring-boot:run -pl rest-api\n</code></pre></p> </li> <li> <p>Open the Swagger UI:     Once the application is running, you can access the Swagger UI at the following URL:</p> <p>http://localhost:8080/swagger-ui.html</p> </li> </ol> <p>This will open an interactive web page where you can explore all the API endpoints, view their details, and even send test requests directly from your browser.</p>"},{"location":"authentication/","title":"Authentication Methods","text":"<p>This section covers all authentication methods implemented in the Spring Security Reference Project. Each method demonstrates different use cases and integration patterns commonly found in enterprise applications.</p>"},{"location":"authentication/#overview","title":"\ud83c\udfaf Overview","text":"<p>The project implements four distinct authentication strategies, each designed for different scenarios:</p> Method Module Use Case Complexity JDBC Authentication <code>jdbc-auth</code> Database-backed users \u2b50\u2b50 LDAP Authentication <code>ldap-auth</code> Enterprise directories \u2b50\u2b50\u2b50 OAuth2 Authentication <code>oauth2-auth</code> Social login, SSO \u2b50\u2b50\u2b50\u2b50 JWT Tokens <code>common-auth</code> Stateless API auth \u2b50\u2b50\u2b50"},{"location":"authentication/#authentication-architecture","title":"\ud83c\udfd7\ufe0f Authentication Architecture","text":"<pre><code>graph TD\n    A[HTTP Request] --&gt; B{Authentication Required?}\n    B --&gt;|No| C[Public Endpoint]\n    B --&gt;|Yes| D[Security Filter Chain]\n\n    D --&gt; E{Auth Method}\n    E --&gt;|JWT Token| F[JWT Filter]\n    E --&gt;|Form Login| G[Login Form]\n    E --&gt;|Basic Auth| H[Basic Auth Filter]\n\n    F --&gt; I[JWT Provider]\n    G --&gt; J{Provider Type}\n    H --&gt; J\n\n    J --&gt;|JDBC| K[JDBC Provider]\n    J --&gt;|LDAP| L[LDAP Provider]  \n    J --&gt;|OAuth2| M[OAuth2 Provider]\n\n    K --&gt; N[Database]\n    L --&gt; O[LDAP Directory]\n    M --&gt; P[Identity Provider]\n\n    I --&gt; Q[Security Context]\n    K --&gt; Q\n    L --&gt; Q\n    M --&gt; Q\n\n    Q --&gt; R[Authorized Request]</code></pre>"},{"location":"authentication/#authentication-flow","title":"\ud83d\udd04 Authentication Flow","text":""},{"location":"authentication/#standard-flow","title":"Standard Flow","text":"<p>Every authentication method follows the same basic pattern:</p> <ol> <li>Request Intercepted: Security filters examine incoming requests</li> <li>Credentials Extracted: Username/password, token, or OAuth2 code</li> <li>Provider Selection: Choose appropriate authentication provider</li> <li>Validation: Verify credentials against user store</li> <li>Authorization: Load user roles and permissions</li> <li>Security Context: Set authenticated user in context</li> <li>Request Processing: Continue to protected resource</li> </ol>"},{"location":"authentication/#flow-variations","title":"Flow Variations","text":"<p>Each authentication method has unique characteristics:</p>"},{"location":"authentication/#database-jdbc-flow","title":"Database (JDBC) Flow","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant F as JWT Filter\n    participant P as JDBC Provider\n    participant D as Database\n\n    U-&gt;&gt;F: POST /api/auth/login\n    F-&gt;&gt;P: Authenticate(username, password)\n    P-&gt;&gt;D: SELECT user WHERE username=?\n    D--&gt;&gt;P: User record\n    P-&gt;&gt;P: Verify BCrypt password\n    P--&gt;&gt;F: Authentication success\n    F--&gt;&gt;U: JWT Token</code></pre>"},{"location":"authentication/#directory-ldap-flow","title":"Directory (LDAP) Flow","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant F as Form Filter\n    participant P as LDAP Provider\n    participant L as LDAP Server\n\n    U-&gt;&gt;F: Form Login\n    F-&gt;&gt;P: Authenticate(username, password)\n    P-&gt;&gt;L: Search user in directory\n    L--&gt;&gt;P: User DN\n    P-&gt;&gt;L: Bind with user credentials\n    L--&gt;&gt;P: Bind successful\n    P-&gt;&gt;L: Get user groups\n    L--&gt;&gt;P: Group memberships\n    P--&gt;&gt;F: Authentication + Authorities\n    F--&gt;&gt;U: Redirect to secured page</code></pre>"},{"location":"authentication/#oauth2-flow","title":"OAuth2 Flow","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant A as Application\n    participant P as OAuth2 Provider\n\n    U-&gt;&gt;A: Click \"Login with Google\"\n    A-&gt;&gt;P: Redirect to authorization URL\n    P-&gt;&gt;U: Present consent screen\n    U-&gt;&gt;P: Approve application\n    P-&gt;&gt;A: Redirect with authorization code\n    A-&gt;&gt;P: Exchange code for tokens\n    P--&gt;&gt;A: Access token + ID token\n    A-&gt;&gt;P: Get user profile\n    P--&gt;&gt;A: User information\n    A--&gt;&gt;U: Authenticated session</code></pre>"},{"location":"authentication/#configuration-patterns","title":"\ud83d\udd27 Configuration Patterns","text":""},{"location":"authentication/#multiple-authentication-providers","title":"Multiple Authentication Providers","text":"<p>The project demonstrates how to combine multiple authentication methods:</p> <pre><code>@Configuration\npublic class SecurityConfig {\n\n    @Bean\n    public AuthenticationManager authenticationManager(\n            JdbcAuthenticationProvider jdbcProvider,\n            LdapAuthenticationProvider ldapProvider) {\n\n        return new ProviderManager(\n            Arrays.asList(jdbcProvider, ldapProvider)\n        );\n    }\n}\n</code></pre>"},{"location":"authentication/#profile-based-configuration","title":"Profile-Based Configuration","text":"<p>Different authentication methods can be enabled using Spring profiles:</p> <pre><code># application-jdbc.yml\nspring:\n  profiles:\n    include: jdbc-only\n\n# application-ldap.yml  \nspring:\n  profiles:\n    include: ldap-only\n</code></pre>"},{"location":"authentication/#learning-path","title":"\ud83c\udf93 Learning Path","text":""},{"location":"authentication/#beginner-path","title":"Beginner Path","text":"<ol> <li>JDBC Authentication - Start with database auth</li> <li>JWT Tokens - Learn stateless authentication</li> <li>API Testing - Practice with endpoints</li> </ol>"},{"location":"authentication/#intermediate-path","title":"Intermediate Path","text":"<ol> <li>LDAP Authentication - Enterprise directory integration</li> <li>Security Configuration - Advanced security setup</li> <li>Custom Providers - Build custom auth</li> </ol>"},{"location":"authentication/#advanced-path","title":"Advanced Path","text":"<ol> <li>OAuth2 Authentication - Modern identity protocols</li> <li>Advanced Patterns - Complex scenarios</li> <li>Production Setup - Deploy securely</li> </ol>"},{"location":"authentication/#comparison-matrix","title":"\ud83d\udd0d Comparison Matrix","text":"Feature JDBC LDAP OAuth2 JWT User Storage Database Directory External Provider Stateless Password Management Application Directory Provider N/A Enterprise Integration Medium High High High Scalability High High Very High Very High Setup Complexity Low Medium High Low Offline Capability Yes No No Yes Social Login No No Yes N/A Session State Stateful Stateful Stateful Stateless"},{"location":"authentication/#implementation-tips","title":"\ud83d\udd28 Implementation Tips","text":""},{"location":"authentication/#choosing-the-right-method","title":"Choosing the Right Method","text":"<ul> <li>JDBC: Internal applications with custom user management</li> <li>LDAP: Enterprise environments with existing directories</li> <li>OAuth2: Public applications or SSO requirements</li> <li>JWT: APIs, microservices, or stateless architectures</li> </ul>"},{"location":"authentication/#best-practices","title":"Best Practices","text":"<ol> <li>Security First: Always use HTTPS in production</li> <li>Password Policies: Implement strong password requirements</li> <li>Token Expiry: Set appropriate token lifetimes</li> <li>Logging: Monitor authentication attempts</li> <li>Error Handling: Don't leak sensitive information</li> </ol>"},{"location":"authentication/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>Password Storage: Never store plain text passwords</li> <li>Token Security: Protect JWT signing keys</li> <li>Session Management: Consider session fixation attacks</li> <li>Rate Limiting: Prevent brute force attacks</li> </ul>"},{"location":"authentication/#next-steps","title":"\ud83d\udd17 Next Steps","text":"<p>Ready to dive deeper? Explore specific authentication methods:</p> <ul> <li>JDBC Authentication \u2192 Database-backed authentication</li> <li>LDAP Authentication \u2192 Directory service integration</li> <li>OAuth2 Authentication \u2192 Modern identity protocols</li> <li>JWT Tokens \u2192 Stateless token authentication</li> </ul> <p>Or explore related topics:</p> <ul> <li>Security Configuration \u2192 Learn security setup patterns</li> <li>API Reference \u2192 Test endpoints and flows</li> <li>Examples &amp; Tutorials \u2192 Practice with real scenarios</li> </ul>"},{"location":"authentication/jdbc-auth/","title":"JDBC Authentication","text":"<p>The <code>jdbc-auth</code> module provides database-backed user authentication using Spring Security's built-in JDBC support with BCrypt password encoding and H2 database storage.</p>"},{"location":"authentication/jdbc-auth/#overview","title":"\ud83c\udfaf Overview","text":"<p>JDBC authentication is ideal for applications that need to manage their own user accounts in a relational database. This implementation demonstrates:</p> <ul> <li>Database User Storage: Users and roles stored in H2 database</li> <li>BCrypt Password Encoding: Secure password hashing with salt</li> <li>JdbcUserDetailsManager: Spring Security's standard JDBC user management</li> <li>Auto-initialization: Demo users created on application startup</li> <li>Standard Schema: Uses Spring Security's default JDBC schema</li> </ul>"},{"location":"authentication/jdbc-auth/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>graph TD\n    A[User Login Request] --&gt; B[JDBC Authentication Provider]\n    B --&gt; C[JdbcUserDetailsService]\n    C --&gt; D[H2 Database]\n    D --&gt; E[Users Table]\n    D --&gt; F[Authorities Table]\n    E --&gt; G[BCrypt Password Check]\n    F --&gt; H[Load User Roles]\n    G --&gt; I[Authentication Success]\n    H --&gt; I\n    I --&gt; J[Security Context]</code></pre>"},{"location":"authentication/jdbc-auth/#database-schema","title":"\ud83d\udcca Database Schema","text":"<p>The module uses Spring Security's standard JDBC schema:</p>"},{"location":"authentication/jdbc-auth/#users-table","title":"Users Table","text":"<pre><code>CREATE TABLE users (\n    username VARCHAR(50) NOT NULL PRIMARY KEY,\n    password VARCHAR(500) NOT NULL,\n    enabled BOOLEAN NOT NULL\n);\n</code></pre>"},{"location":"authentication/jdbc-auth/#authorities-table","title":"Authorities Table","text":"<pre><code>CREATE TABLE authorities (\n    username VARCHAR(50) NOT NULL,\n    authority VARCHAR(50) NOT NULL,\n    CONSTRAINT authorities_idx_1 UNIQUE (username, authority),\n    CONSTRAINT authorities_users_fk FOREIGN KEY (username) REFERENCES users (username)\n);\n</code></pre>"},{"location":"authentication/jdbc-auth/#demo-users","title":"\ud83d\udc65 Demo Users","text":"<p>The system automatically creates demo users on startup:</p> Username Password Role Permissions <code>jdbcadmin</code> <code>password</code> <code>ROLE_ADMIN</code> Full access to all endpoints <code>jdbcuser</code> <code>password</code> <code>ROLE_USER</code> Access to user endpoints only"},{"location":"authentication/jdbc-auth/#configuration","title":"\ud83d\udd27 Configuration","text":""},{"location":"authentication/jdbc-auth/#jdbcauthconfigjava","title":"JdbcAuthConfig.java","text":"<p>The main configuration class sets up all JDBC authentication components:</p> <pre><code>@Configuration\n@Profile({\"default\", \"jdbc-only\"})\npublic class JdbcAuthConfig {\n\n    @Bean\n    public PasswordEncoder jdbcPasswordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    @Bean\n    public UserDetailsService jdbcUserDetailsService(DataSource dataSource) {\n        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);\n        // Custom SQL queries can be configured here\n        return manager;\n    }\n\n    @Bean\n    public DaoAuthenticationProvider jdbcAuthenticationProvider() {\n        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();\n        provider.setUserDetailsService(jdbcUserDetailsService);\n        provider.setPasswordEncoder(jdbcPasswordEncoder);\n        return provider;\n    }\n}\n</code></pre>"},{"location":"authentication/jdbc-auth/#key-components","title":"Key Components","text":""},{"location":"authentication/jdbc-auth/#bcrypt-password-encoder","title":"BCrypt Password Encoder","text":"<ul> <li>Salt Generation: Each password gets a unique salt</li> <li>Adaptive Hashing: Configurable work factor (default: 10)</li> <li>Security: Resistant to rainbow table attacks</li> </ul>"},{"location":"authentication/jdbc-auth/#jdbcuserdetailsmanager","title":"JdbcUserDetailsManager","text":"<ul> <li>CRUD Operations: Create, read, update, delete users</li> <li>Custom Queries: Override default SQL queries if needed</li> <li>Group Support: Optional group-based permissions</li> </ul>"},{"location":"authentication/jdbc-auth/#daoauthenticationprovider","title":"DaoAuthenticationProvider","text":"<ul> <li>Password Verification: Compares provided password with stored hash</li> <li>User Loading: Retrieves user details from database</li> <li>Authority Mapping: Loads user roles and permissions</li> </ul>"},{"location":"authentication/jdbc-auth/#authentication-flow","title":"\ud83d\udd04 Authentication Flow","text":""},{"location":"authentication/jdbc-auth/#login-process","title":"Login Process","text":"<ol> <li>User Submits Credentials: Username and password via form or API</li> <li>Provider Selection: Spring Security routes to JDBC provider</li> <li>User Lookup: Query database for user record</li> <li>Password Verification: BCrypt compares hashes</li> <li>Authority Loading: Retrieve user roles from authorities table</li> <li>Authentication Object: Create authenticated principal</li> <li>Security Context: Store authentication for request</li> </ol>"},{"location":"authentication/jdbc-auth/#detailed-flow-diagram","title":"Detailed Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant F as Security Filter\n    participant P as JDBC Provider\n    participant S as UserDetailsService\n    participant D as Database\n    participant E as PasswordEncoder\n\n    U-&gt;&gt;F: POST /login (username, password)\n    F-&gt;&gt;P: authenticate(authToken)\n    P-&gt;&gt;S: loadUserByUsername(username)\n    S-&gt;&gt;D: SELECT * FROM users WHERE username=?\n    D--&gt;&gt;S: User record\n    S-&gt;&gt;D: SELECT authority FROM authorities WHERE username=?\n    D--&gt;&gt;S: User authorities\n    S--&gt;&gt;P: UserDetails object\n    P-&gt;&gt;E: matches(rawPassword, encodedPassword)\n    E--&gt;&gt;P: Password valid\n    P--&gt;&gt;F: Authentication successful\n    F--&gt;&gt;U: Redirect to secured page / JWT token</code></pre>"},{"location":"authentication/jdbc-auth/#testing-jdbc-authentication","title":"\ud83e\uddea Testing JDBC Authentication","text":""},{"location":"authentication/jdbc-auth/#using-http-requests","title":"Using HTTP Requests","text":"<pre><code>### Test JDBC Admin Login\nPOST http://localhost:8080/api/auth/login\nContent-Type: application/x-www-form-urlencoded\n\nusername=jdbcadmin&amp;password=password\n\n### Test JDBC User Login  \nPOST http://localhost:8080/api/auth/login\nContent-Type: application/x-www-form-urlencoded\n\nusername=jdbcuser&amp;password=password\n\n### Access Admin Endpoint with JDBC User\nGET http://localhost:8080/api/admin/secure\nAuthorization: Bearer {{jwt_token}}\n</code></pre>"},{"location":"authentication/jdbc-auth/#using-curl","title":"Using cURL","text":"<pre><code># Login as JDBC admin\ncurl -X POST http://localhost:8080/api/auth/login \\\n  -d \"username=jdbcadmin&amp;password=password\"\n\n# Use returned JWT token\ncurl -H \"Authorization: Bearer &lt;jwt-token&gt;\" \\\n  http://localhost:8080/api/admin/secure\n\n# Test JDBC-specific endpoint\ncurl -H \"Authorization: Bearer &lt;jwt-token&gt;\" \\\n  http://localhost:8080/api/jdbc/users\n</code></pre>"},{"location":"authentication/jdbc-auth/#educational-logging","title":"\ud83d\udcda Educational Logging","text":"<p>The JDBC authentication module includes comprehensive logging to help understand the authentication process:</p> <pre><code>// Configuration logging\nlogger.info(\"\ud83d\udd27 [JDBC-AUTH] Initializing JDBC Authentication Configuration\");\nlogger.debug(\"\ud83d\udcda [LEARNING] This module provides database-backed user authentication\");\n\n// Authentication process logging\nlogger.info(\"\ud83d\udd10 [JDBC-AUTH] Creating BCrypt password encoder for database users\");\nlogger.debug(\"\ud83d\udcda [LEARNING] BCrypt adds salt and hashing for secure password storage\");\n\n// User creation logging\nlogger.info(\"\ud83d\udc64 [JDBC-DATA] Creating regular user: jdbcuser\");\nlogger.debug(\"\ud83d\udd10 [LEARNING] Same password encoding process as admin user\");\n</code></pre>"},{"location":"authentication/jdbc-auth/#log-analysis","title":"Log Analysis","text":"<p>Monitor these log patterns to understand the authentication flow:</p> <ul> <li><code>\ud83d\udd27 [JDBC-AUTH]</code> - Configuration and setup</li> <li><code>\ud83d\udd10 [JDBC-AUTH]</code> - Password and security operations  </li> <li><code>\ud83d\udc64 [JDBC-DATA]</code> - User management operations</li> <li><code>\ud83d\udcda [LEARNING]</code> - Educational explanations</li> </ul>"},{"location":"authentication/jdbc-auth/#customization","title":"\u2699\ufe0f Customization","text":""},{"location":"authentication/jdbc-auth/#custom-password-policies","title":"Custom Password Policies","text":"<pre><code>@Bean\npublic PasswordEncoder customPasswordEncoder() {\n    return new BCryptPasswordEncoder(12); // Higher work factor\n}\n</code></pre>"},{"location":"authentication/jdbc-auth/#custom-user-schema","title":"Custom User Schema","text":"<pre><code>@Bean\npublic UserDetailsService customJdbcUserDetailsService(DataSource dataSource) {\n    JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);\n\n    // Custom user query\n    manager.setUsersByUsernameQuery(\n        \"SELECT username, password, active FROM app_users WHERE username = ?\"\n    );\n\n    // Custom authorities query\n    manager.setAuthoritiesByUsernameQuery(\n        \"SELECT username, role FROM user_roles WHERE username = ?\"\n    );\n\n    return manager;\n}\n</code></pre>"},{"location":"authentication/jdbc-auth/#adding-new-users-programmatically","title":"Adding New Users Programmatically","text":"<pre><code>@Service\npublic class UserManagementService {\n\n    @Autowired\n    private JdbcUserDetailsManager userDetailsManager;\n\n    @Autowired \n    private PasswordEncoder passwordEncoder;\n\n    public void createUser(String username, String password, String role) {\n        UserDetails user = User.builder()\n            .username(username)\n            .password(passwordEncoder.encode(password))\n            .authorities(role)\n            .build();\n\n        userDetailsManager.createUser(user);\n    }\n}\n</code></pre>"},{"location":"authentication/jdbc-auth/#security-best-practices","title":"\ud83d\udd12 Security Best Practices","text":""},{"location":"authentication/jdbc-auth/#password-security","title":"Password Security","text":"<ul> <li>Strong Encoding: Use BCrypt with appropriate work factor</li> <li>Salt Generation: Each password gets unique salt automatically</li> <li>No Plain Text: Never store passwords in plain text</li> </ul>"},{"location":"authentication/jdbc-auth/#database-security","title":"Database Security","text":"<ul> <li>Connection Pooling: Use production database connection pools</li> <li>SQL Injection: JdbcUserDetailsManager uses prepared statements</li> <li>Database Permissions: Limit database user permissions</li> </ul>"},{"location":"authentication/jdbc-auth/#production-considerations","title":"Production Considerations","text":"<ul> <li>Database Migration: Use production-grade databases (PostgreSQL, MySQL)</li> <li>Connection Security: Use encrypted database connections</li> <li>User Management: Implement user registration and password reset flows</li> </ul>"},{"location":"authentication/jdbc-auth/#production-setup","title":"\ud83d\ude80 Production Setup","text":""},{"location":"authentication/jdbc-auth/#database-configuration","title":"Database Configuration","text":"<pre><code># application-prod.yml\nspring:\n  datasource:\n    url: jdbc:postgresql://localhost:5432/security_db\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n    driver-class-name: org.postgresql.Driver\n\n  jpa:\n    hibernate:\n      ddl-auto: validate\n    show-sql: false\n</code></pre>"},{"location":"authentication/jdbc-auth/#environment-variables","title":"Environment Variables","text":"<pre><code>export DB_USERNAME=security_user\nexport DB_PASSWORD=secure_password\nexport BCRYPT_STRENGTH=12\n</code></pre>"},{"location":"authentication/jdbc-auth/#related-topics","title":"\ud83d\udd17 Related Topics","text":"<ul> <li>Security Configuration - How JDBC auth integrates with security config</li> <li>JWT Tokens - Using JWTs with JDBC authentication</li> <li>API Testing - Testing JDBC auth endpoints</li> <li>Production Setup - Deploying with database authentication</li> </ul>"},{"location":"authentication/jwt-tokens/","title":"JWT Tokens","text":"<p>Comprehensive guide to JSON Web Token (JWT) authentication in the Spring Security Reference project. Learn how to generate, validate, and use JWTs for stateless authentication.</p>"},{"location":"authentication/jwt-tokens/#jwt-overview","title":"\ud83c\udfaf JWT Overview","text":"<p>JSON Web Tokens (JWTs) provide a stateless authentication mechanism that encodes user identity and claims in a cryptographically signed token.</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant A as Auth Endpoint\n    participant J as JWT Util\n    participant F as JWT Filter\n    participant R as Resource\n\n    Note over C,R: JWT Authentication Flow\n    C-&gt;&gt;A: POST /api/auth/login&lt;br/&gt;username + password\n    A-&gt;&gt;J: Generate JWT\n    J-&gt;&gt;J: Create claims (sub, role, exp)\n    J-&gt;&gt;J: Sign with secret key\n    J--&gt;&gt;A: Signed JWT Token\n    A--&gt;&gt;C: {\"token\": \"eyJhbGci...\"}\n\n    Note over C,R: Using JWT Token\n    C-&gt;&gt;F: Request with Authorization: Bearer &lt;token&gt;\n    F-&gt;&gt;J: Validate JWT signature\n    F-&gt;&gt;J: Check token expiration\n    J--&gt;&gt;F: Claims extracted\n    F-&gt;&gt;F: Create Authentication object\n    F-&gt;&gt;R: Forward authenticated request\n    R--&gt;&gt;C: Protected resource</code></pre>"},{"location":"authentication/jwt-tokens/#jwt-implementation","title":"\ud83d\udd27 JWT Implementation","text":""},{"location":"authentication/jwt-tokens/#jwttokenutil-class","title":"JwtTokenUtil Class","text":"<pre><code>@Component\npublic class JwtTokenUtil {\n\n    private static final Logger logger = LogManager.getLogger(JwtTokenUtil.class);\n    private static final String SECRET = \"MySuperSecretKey\";\n    private static final int EXPIRATION_TIME = 86400000; // 24 hours\n\n    /**\n     * Generate JWT token with user claims\n     */\n    public String generateToken(String username, String role) {\n        logger.info(\"\ud83c\udf9f\ufe0f [JWT] Generating token for user: {}\", username);\n        logger.debug(\"\ud83d\udcda [LEARNING] JWT contains encoded user identity and role claims\");\n\n        Date now = new Date();\n        Date expiryDate = new Date(now.getTime() + EXPIRATION_TIME);\n\n        String token = Jwts.builder()\n                .setSubject(username)\n                .claim(\"role\", role)\n                .setIssuedAt(now)\n                .setExpiration(expiryDate)\n                .signWith(SignatureAlgorithm.HS512, SECRET)\n                .compact();\n\n        logger.debug(\"\ud83d\udd10 [JWT] Token generated successfully\");\n        logger.debug(\"   \u2022 Subject: {}\", username);\n        logger.debug(\"   \u2022 Role: {}\", role);\n        logger.debug(\"   \u2022 Expires: {}\", expiryDate);\n        logger.debug(\"\ud83d\udcda [LEARNING] Token is signed with HMAC-SHA512\");\n\n        return token;\n    }\n\n    /**\n     * Extract claims from JWT token\n     */\n    public Claims getClaimsFromToken(String token) {\n        logger.debug(\"\ud83d\udd0d [JWT] Extracting claims from token\");\n\n        try {\n            Claims claims = Jwts.parser()\n                    .setSigningKey(SECRET)\n                    .parseClaimsJws(token)\n                    .getBody();\n\n            logger.debug(\"\u2705 [JWT] Claims extracted successfully\");\n            logger.debug(\"   \u2022 Subject: {}\", claims.getSubject());\n            logger.debug(\"   \u2022 Role: {}\", claims.get(\"role\"));\n            logger.debug(\"   \u2022 Expires: {}\", claims.getExpiration());\n\n            return claims;\n        } catch (ExpiredJwtException e) {\n            logger.warn(\"\u23f0 [JWT] Token has expired: {}\", e.getMessage());\n            throw e;\n        } catch (JwtException e) {\n            logger.warn(\"\u274c [JWT] Invalid token: {}\", e.getMessage());\n            throw e;\n        }\n    }\n\n    /**\n     * Check if JWT token is expired\n     */\n    public boolean isTokenExpired(String token) {\n        try {\n            Claims claims = getClaimsFromToken(token);\n            boolean expired = claims.getExpiration().before(new Date());\n\n            logger.debug(\"\ud83d\udd52 [JWT] Token expiry check: {}\", expired ? \"EXPIRED\" : \"VALID\");\n            return expired;\n        } catch (ExpiredJwtException e) {\n            logger.debug(\"\ud83d\udd52 [JWT] Token is expired\");\n            return true;\n        }\n    }\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#jwt-authentication-filter","title":"JWT Authentication Filter","text":"<pre><code>@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    private static final Logger logger = LogManager.getLogger(JwtAuthenticationFilter.class);\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws ServletException, IOException {\n\n        logger.debug(\"\ud83d\udd0d [JWT-FILTER] Processing request: {}\", request.getRequestURI());\n\n        String header = request.getHeader(\"Authorization\");\n        String jwtToken = null;\n\n        // Extract JWT token from Authorization header\n        if (header != null &amp;&amp; header.startsWith(\"Bearer \")) {\n            jwtToken = header.substring(7);\n            logger.debug(\"\ud83c\udf9f\ufe0f [JWT-FILTER] JWT token found in request\");\n\n            try {\n                Claims claims = jwtTokenUtil.getClaimsFromToken(jwtToken);\n                String username = claims.getSubject();\n                String role = claims.get(\"role\", String.class);\n\n                if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {\n                    logger.debug(\"\ud83d\udd10 [JWT-FILTER] Setting authentication for user: {}\", username);\n\n                    List&lt;SimpleGrantedAuthority&gt; authorities = List.of(\n                            new SimpleGrantedAuthority(role)\n                    );\n\n                    UsernamePasswordAuthenticationToken authToken =\n                            new UsernamePasswordAuthenticationToken(username, null, authorities);\n\n                    SecurityContextHolder.getContext().setAuthentication(authToken);\n\n                    logger.debug(\"\u2705 [JWT-FILTER] Authentication set successfully\");\n                    logger.debug(\"\ud83d\udcda [LEARNING] User authenticated via JWT token\");\n                }\n            } catch (ExpiredJwtException e) {\n                logger.warn(\"\u23f0 [JWT-FILTER] JWT token expired: {}\", e.getMessage());\n                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                response.getWriter().write(\"{\\\"error\\\": \\\"JWT token expired\\\"}\");\n                return;\n            } catch (Exception e) {\n                logger.warn(\"\u274c [JWT-FILTER] Invalid JWT token: {}\", e.getMessage());\n            }\n        } else {\n            logger.debug(\"\ud83d\udd0d [JWT-FILTER] No JWT token found in Authorization header\");\n        }\n\n        chain.doFilter(request, response);\n    }\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#jwt-token-structure","title":"\ud83c\udfaf JWT Token Structure","text":""},{"location":"authentication/jwt-tokens/#header","title":"Header","text":"<pre><code>{\n  \"alg\": \"HS512\",\n  \"typ\": \"JWT\"\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#payload-claims","title":"Payload (Claims)","text":"<pre><code>{\n  \"sub\": \"admin\",\n  \"role\": \"ROLE_ADMIN\",\n  \"iat\": 1694520000,\n  \"exp\": 1694606400\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#signature","title":"Signature","text":"<pre><code>HMACSHA512(\n  base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\n  \"MySuperSecretKey\"\n)\n</code></pre>"},{"location":"authentication/jwt-tokens/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"authentication/jwt-tokens/#1-generate-jwt-token","title":"1. Generate JWT Token","text":"<pre><code>curl -X POST http://localhost:8080/api/auth/login \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=admin&amp;password=password\"\n</code></pre> <p>Response: <pre><code>{\n  \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJST0xFX0FETUlOIiwiaWF0IjoxNjk0NTIwMDAwLCJleHAiOjE2OTQ2MDY0MDB9.signature\",\n  \"username\": \"admin\",\n  \"role\": \"ROLE_ADMIN\",\n  \"message\": \"Login successful - use this JWT token for authenticated requests\"\n}\n</code></pre></p>"},{"location":"authentication/jwt-tokens/#2-use-jwt-token-for-api-access","title":"2. Use JWT Token for API Access","text":"<pre><code># Admin endpoint\ncurl -H \"Authorization: Bearer eyJhbGci...\" \\\n  http://localhost:8080/api/admin/secure\n\n# User endpoint\ncurl -H \"Authorization: Bearer eyJhbGci...\" \\\n  http://localhost:8080/api/user/secure\n\n# Auth info endpoint\ncurl -H \"Authorization: Bearer eyJhbGci...\" \\\n  http://localhost:8080/api/auth/info\n</code></pre>"},{"location":"authentication/jwt-tokens/#security-configuration","title":"\ud83d\udd10 Security Configuration","text":""},{"location":"authentication/jwt-tokens/#adding-jwt-filter-to-security-chain","title":"Adding JWT Filter to Security Chain","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Autowired\n    private JwtAuthenticationFilter jwtAuthenticationFilter;\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n            // Add JWT filter before UsernamePasswordAuthenticationFilter\n            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n\n            .authorizeHttpRequests(authz -&gt; authz\n                .requestMatchers(\"/api/public/**\", \"/api/auth/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n                .anyRequest().authenticated()\n            )\n\n            // Disable session management for stateless JWT authentication\n            .sessionManagement(session -&gt; session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            )\n\n            // Disable CSRF for stateless APIs\n            .csrf(csrf -&gt; csrf.disable())\n\n            .build();\n    }\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#testing-jwt-authentication","title":"\ud83e\uddea Testing JWT Authentication","text":""},{"location":"authentication/jwt-tokens/#unit-tests","title":"Unit Tests","text":"<pre><code>@ExtendWith(MockitoExtension.class)\nclass JwtTokenUtilTest {\n\n    @InjectMocks\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Test\n    void shouldGenerateValidJwtToken() {\n        // Given\n        String username = \"testuser\";\n        String role = \"ROLE_USER\";\n\n        // When\n        String token = jwtTokenUtil.generateToken(username, role);\n\n        // Then\n        assertThat(token).isNotNull();\n        assertThat(token.split(\"\\\\.\")).hasSize(3); // header.payload.signature\n\n        Claims claims = jwtTokenUtil.getClaimsFromToken(token);\n        assertThat(claims.getSubject()).isEqualTo(username);\n        assertThat(claims.get(\"role\")).isEqualTo(role);\n    }\n\n    @Test\n    void shouldThrowExceptionForExpiredToken() {\n        // Given - create expired token (mock implementation)\n        String expiredToken = createExpiredToken();\n\n        // When &amp; Then\n        assertThatThrownBy(() -&gt; jwtTokenUtil.getClaimsFromToken(expiredToken))\n            .isInstanceOf(ExpiredJwtException.class);\n    }\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#integration-tests","title":"Integration Tests","text":"<pre><code>@SpringBootTest\n@AutoConfigureTestDatabase\nclass JwtAuthenticationIntegrationTest {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void shouldAuthenticateWithValidJwtToken() {\n        // Step 1: Get JWT token\n        ResponseEntity&lt;Map&gt; loginResponse = restTemplate.postForEntity(\n            \"/api/auth/login\",\n            createLoginRequest(\"admin\", \"password\"),\n            Map.class\n        );\n\n        String token = (String) loginResponse.getBody().get(\"token\");\n        assertThat(token).isNotNull();\n\n        // Step 2: Use JWT token to access protected endpoint\n        HttpHeaders headers = new HttpHeaders();\n        headers.setBearerAuth(token);\n\n        ResponseEntity&lt;Map&gt; response = restTemplate.exchange(\n            \"/api/admin/secure\",\n            HttpMethod.GET,\n            new HttpEntity&lt;&gt;(headers),\n            Map.class\n        );\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody().get(\"user\")).isEqualTo(\"admin\");\n    }\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#jwt-best-practices","title":"\u26a1 JWT Best Practices","text":""},{"location":"authentication/jwt-tokens/#dos","title":"\u2705 Do's","text":"<ol> <li>Use strong secret keys - Minimum 256-bit keys for HS256</li> <li>Set appropriate expiration times - Short-lived tokens (15 minutes to 1 hour)</li> <li>Implement token refresh mechanism - Refresh tokens for session management</li> <li>Validate tokens on every request - Never trust client-side validation</li> <li>Use HTTPS in production - Prevent token interception</li> </ol>"},{"location":"authentication/jwt-tokens/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't store sensitive data in JWT payload (it's base64 encoded, not encrypted)</li> <li>Don't use predictable secret keys - Use cryptographically secure random keys</li> <li>Don't ignore token expiration - Always check exp claim</li> <li>Don't use JWT for session data - Keep tokens lightweight</li> <li>Don't use JWT for logout - Implement token blacklisting if needed</li> </ol>"},{"location":"authentication/jwt-tokens/#production-configuration","title":"\ud83d\udd27 Production Configuration","text":"<pre><code># application-production.yml\njwt:\n  secret: ${JWT_SECRET:} # Use environment variable\n  expiration: 3600000    # 1 hour\n  refresh-expiration: 86400000 # 24 hours\n  issuer: \"spring-security-reference\"\n\nlogging:\n  level:\n    com.example.commonauth.JwtTokenUtil: INFO # Reduce debug logging\n</code></pre>"},{"location":"authentication/jwt-tokens/#token-refresh-pattern","title":"\ud83d\udd04 Token Refresh Pattern","text":"<pre><code>@RestController\npublic class TokenController {\n\n    @PostMapping(\"/api/auth/refresh\")\n    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; refreshToken(\n            @RequestBody Map&lt;String, String&gt; request) {\n\n        String refreshToken = request.get(\"refreshToken\");\n\n        if (isValidRefreshToken(refreshToken)) {\n            String username = extractUsernameFromRefreshToken(refreshToken);\n            String role = getUserRole(username);\n\n            String newAccessToken = jwtTokenUtil.generateToken(username, role);\n            String newRefreshToken = generateRefreshToken(username);\n\n            return ResponseEntity.ok(Map.of(\n                \"accessToken\", newAccessToken,\n                \"refreshToken\", newRefreshToken\n            ));\n        }\n\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n            .body(Map.of(\"error\", \"Invalid refresh token\"));\n    }\n}\n</code></pre>"},{"location":"authentication/jwt-tokens/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>LDAP Authentication \u2192 - Directory-based authentication</li> <li>OAuth2 Authentication \u2192 - Social login integration</li> <li>SSO Integration \u2192 - Single Sign-On patterns</li> <li>API Reference \u2192 - Using JWTs with REST APIs</li> <li>Security Configuration \u2192 - JWT filter implementation</li> </ul> <p>\ud83c\udf9f\ufe0f JWT tokens provide stateless authentication perfect for modern APIs and microservices. Understanding token generation, validation, and security best practices is essential for building secure distributed systems.</p>"},{"location":"authentication/ldap-auth/","title":"LDAP Authentication","text":"<p>Comprehensive guide to Lightweight Directory Access Protocol (LDAP) authentication in Spring Security. Learn how to integrate with directory services like Active Directory and OpenLDAP.</p>"},{"location":"authentication/ldap-auth/#ldap-overview","title":"\ud83c\udfe2 LDAP Overview","text":"<p>LDAP authentication allows integration with enterprise directory services, providing centralized user management and authentication.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant A as Application\n    participant L as LDAP Server\n    participant D as Directory\n\n    Note over U,D: LDAP Authentication Flow\n    U-&gt;&gt;A: Login (username/password)\n    A-&gt;&gt;L: Bind request with credentials\n    L-&gt;&gt;D: Authenticate against directory\n    D--&gt;&gt;L: Authentication result\n    L--&gt;&gt;A: Success + User attributes\n    A-&gt;&gt;A: Load user authorities\n    A-&gt;&gt;A: Create Security Context\n    A--&gt;&gt;U: Authentication successful</code></pre>"},{"location":"authentication/ldap-auth/#ldap-configuration","title":"\ud83d\udd27 LDAP Configuration","text":""},{"location":"authentication/ldap-auth/#embedded-ldap-server-testing","title":"Embedded LDAP Server (Testing)","text":"<pre><code>@Configuration\n@Profile(\"ldap\")\npublic class LdapConfig {\n\n    private static final Logger logger = LogManager.getLogger(LdapConfig.class);\n\n    @Bean\n    public ContextSource contextSource() {\n        logger.info(\"\ud83c\udfe2 [LDAP-CONFIG] Configuring embedded LDAP server\");\n        logger.debug(\"\ud83d\udcda [LEARNING] Embedded LDAP is for testing - use external LDAP in production\");\n\n        return new EmbeddedLdapServerContextSourceFactoryBean()\n                .setLdif(\"classpath:users.ldif\")\n                .setBase(\"dc=springframework,dc=org\")\n                .setPort(8389)\n                .getContextSource();\n    }\n\n    @Bean\n    public LdapAuthenticationProvider ldapAuthenticationProvider() {\n        logger.info(\"\ud83d\udd10 [LDAP-CONFIG] Setting up LDAP authentication provider\");\n\n        // Bind authenticator - authenticates by binding to LDAP\n        BindAuthenticator authenticator = new BindAuthenticator(contextSource());\n        authenticator.setUserDnPatterns(new String[]{\"uid={0},ou=people\"});\n\n        // Authorities populator - loads user roles from LDAP groups\n        DefaultLdapAuthoritiesPopulator authoritiesPopulator = \n                new DefaultLdapAuthoritiesPopulator(contextSource(), \"ou=groups\");\n        authoritiesPopulator.setGroupRoleAttribute(\"cn\");\n        authoritiesPopulator.setGroupSearchFilter(\"member={0}\");\n        authoritiesPopulator.setRolePrefix(\"ROLE_\");\n        authoritiesPopulator.setConvertToUpperCase(true);\n\n        LdapAuthenticationProvider provider = \n                new LdapAuthenticationProvider(authenticator, authoritiesPopulator);\n\n        logger.debug(\"\u2705 [LDAP-CONFIG] LDAP authentication provider configured\");\n        logger.debug(\"\ud83d\udcda [LEARNING] Users authenticated via LDAP bind operation\");\n\n        return provider;\n    }\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#external-ldap-server-configuration","title":"External LDAP Server Configuration","text":"<pre><code>@Configuration\n@Profile(\"ldap-production\")\npublic class ExternalLdapConfig {\n\n    @Value(\"${ldap.url:ldap://localhost:389}\")\n    private String ldapUrl;\n\n    @Value(\"${ldap.base:dc=example,dc=com}\")\n    private String ldapBase;\n\n    @Value(\"${ldap.username:}\")\n    private String ldapUsername;\n\n    @Value(\"${ldap.password:}\")\n    private String ldapPassword;\n\n    @Bean\n    public ContextSource contextSource() {\n        LdapContextSource context = new LdapContextSource();\n        context.setUrl(ldapUrl);\n        context.setBase(ldapBase);\n\n        // Manager credentials for searching\n        if (!ldapUsername.isEmpty()) {\n            context.setUserDn(ldapUsername);\n            context.setPassword(ldapPassword);\n        }\n\n        context.afterPropertiesSet();\n        return context;\n    }\n\n    @Bean\n    public LdapAuthenticationProvider ldapAuthenticationProvider() {\n        // Search and bind pattern\n        FilterBasedLdapUserSearch userSearch = \n                new FilterBasedLdapUserSearch(\"\", \"(uid={0})\", contextSource());\n\n        BindAuthenticator authenticator = new BindAuthenticator(contextSource());\n        authenticator.setUserSearch(userSearch);\n\n        // Custom authorities populator\n        DefaultLdapAuthoritiesPopulator authoritiesPopulator = \n                new DefaultLdapAuthoritiesPopulator(contextSource(), \"ou=roles\");\n        authoritiesPopulator.setGroupRoleAttribute(\"cn\");\n        authoritiesPopulator.setGroupSearchFilter(\"uniqueMember={0}\");\n\n        return new LdapAuthenticationProvider(authenticator, authoritiesPopulator);\n    }\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#ldif-test-data","title":"\ud83d\udcca LDIF Test Data","text":""},{"location":"authentication/ldap-auth/#usersldif","title":"users.ldif","text":"<pre><code>dn: dc=springframework,dc=org\nobjectclass: top\nobjectclass: domain\nobjectclass: extensibleObject\ndc: springframework\n\ndn: ou=groups,dc=springframework,dc=org\nobjectclass: top\nobjectclass: organizationalUnit\nou: groups\n\ndn: ou=people,dc=springframework,dc=org\nobjectclass: top\nobjectclass: organizationalUnit\nou: people\n\n# Users\ndn: uid=ldapadmin,ou=people,dc=springframework,dc=org\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\ncn: LDAP Admin\nsn: Admin\nuid: ldapadmin\nuserPassword: password\n\ndn: uid=ldapuser,ou=people,dc=springframework,dc=org\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\ncn: LDAP User\nsn: User\nuid: ldapuser\nuserPassword: password\n\n# Groups\ndn: cn=ADMIN,ou=groups,dc=springframework,dc=org\nobjectclass: top\nobjectclass: groupOfNames\ncn: ADMIN\nmember: uid=ldapadmin,ou=people,dc=springframework,dc=org\n\ndn: cn=USER,ou=groups,dc=springframework,dc=org\nobjectclass: top\nobjectclass: groupOfNames\ncn: USER\nmember: uid=ldapuser,ou=people,dc=springframework,dc=org\nmember: uid=ldapadmin,ou=people,dc=springframework,dc=org\n</code></pre>"},{"location":"authentication/ldap-auth/#security-configuration","title":"\ud83d\udd10 Security Configuration","text":""},{"location":"authentication/ldap-auth/#ldap-security-filter-chain","title":"LDAP Security Filter Chain","text":"<pre><code>@Configuration\n@EnableWebSecurity\n@Profile(\"ldap\")\npublic class LdapSecurityConfig {\n\n    private static final Logger logger = LogManager.getLogger(LdapSecurityConfig.class);\n\n    @Autowired\n    private LdapAuthenticationProvider ldapAuthenticationProvider;\n\n    @Bean\n    public SecurityFilterChain ldapFilterChain(HttpSecurity http) throws Exception {\n        logger.info(\"\ud83d\udd10 [LDAP-SECURITY] Configuring LDAP security filter chain\");\n        logger.debug(\"\ud83d\udcda [LEARNING] LDAP authentication via HTTP Basic Auth\");\n\n        return http\n            .authenticationProvider(ldapAuthenticationProvider)\n\n            .authorizeHttpRequests(authz -&gt; authz\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/ldap/**\").authenticated()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n                .anyRequest().authenticated()\n            )\n\n            .httpBasic(basic -&gt; basic\n                .realmName(\"LDAP Authentication\")\n            )\n\n            .sessionManagement(session -&gt; session\n                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n            )\n\n            .csrf(csrf -&gt; csrf.disable())\n\n            .build();\n    }\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"authentication/ldap-auth/#1-ldap-authentication-with-curl","title":"1. LDAP Authentication with cURL","text":"<pre><code># Authenticate LDAP admin user\ncurl -u ldapadmin:password \\\n  http://localhost:8080/api/ldap/users\n\n# Authenticate LDAP regular user  \ncurl -u ldapuser:password \\\n  http://localhost:8080/api/ldap/users\n\n# Base64 encoded credentials\ncurl -H \"Authorization: Basic bGRhcGFkbWluOnBhc3N3b3Jk\" \\\n  http://localhost:8080/api/ldap/users\n</code></pre>"},{"location":"authentication/ldap-auth/#2-ldap-response-example","title":"2. LDAP Response Example","text":"<pre><code>{\n  \"message\": \"LDAP Authentication Demo\",\n  \"user\": \"ldapadmin\",\n  \"credentials\": {\n    \"ldapadmin\": \"password (ROLE_ADMIN)\",\n    \"ldapuser\": \"password (ROLE_USER)\"\n  },\n  \"authType\": \"LDAP\",\n  \"authorities\": [\n    {\n      \"authority\": \"ROLE_ADMIN\"\n    },\n    {\n      \"authority\": \"ROLE_USER\"\n    }\n  ]\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#custom-ldap-user-details","title":"\ud83d\udd0d Custom LDAP User Details","text":""},{"location":"authentication/ldap-auth/#ldapuserdetailsmapper","title":"LdapUserDetailsMapper","text":"<pre><code>@Component\npublic class CustomLdapUserDetailsMapper implements UserDetailsContextMapper {\n\n    private static final Logger logger = LogManager.getLogger(CustomLdapUserDetailsMapper.class);\n\n    @Override\n    public UserDetails mapUserFromContext(DirContextOperations ctx, \n                                          String username, \n                                          Collection&lt;? extends GrantedAuthority&gt; authorities) {\n\n        logger.debug(\"\ud83d\udd0d [LDAP-MAPPER] Mapping LDAP user: {}\", username);\n\n        // Extract additional LDAP attributes\n        String fullName = ctx.getStringAttribute(\"cn\");\n        String email = ctx.getStringAttribute(\"mail\");\n        String department = ctx.getStringAttribute(\"departmentNumber\");\n\n        logger.debug(\"\ud83d\udcca [LDAP-MAPPER] User attributes:\");\n        logger.debug(\"   \u2022 Full Name: {}\", fullName);\n        logger.debug(\"   \u2022 Email: {}\", email);\n        logger.debug(\"   \u2022 Department: {}\", department);\n        logger.debug(\"   \u2022 Authorities: {}\", authorities);\n\n        // Create custom user details with LDAP attributes\n        return LdapUserDetails.builder()\n                .username(username)\n                .password(\"[PROTECTED]\")\n                .authorities(authorities)\n                .fullName(fullName)\n                .email(email)\n                .department(department)\n                .accountNonExpired(true)\n                .accountNonLocked(true)\n                .credentialsNonExpired(true)\n                .enabled(true)\n                .build();\n    }\n\n    @Override\n    public void mapUserToContext(UserDetails user, DirContextAdapter ctx) {\n        // Used for user creation/update - not typically needed for authentication\n        logger.debug(\"\ud83d\udd04 [LDAP-MAPPER] Mapping user to LDAP context: {}\", user.getUsername());\n    }\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#custom-ldap-user-details-class","title":"Custom LDAP User Details Class","text":"<pre><code>public class LdapUserDetails implements UserDetails {\n\n    private final String username;\n    private final String password;\n    private final Collection&lt;? extends GrantedAuthority&gt; authorities;\n    private final String fullName;\n    private final String email;\n    private final String department;\n    private final boolean accountNonExpired;\n    private final boolean accountNonLocked;\n    private final boolean credentialsNonExpired;\n    private final boolean enabled;\n\n    // Constructor, getters, and builder pattern implementation\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n        return authorities;\n    }\n\n    // Additional getters for LDAP attributes\n    public String getFullName() {\n        return fullName;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getDepartment() {\n        return department;\n    }\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#testing-ldap-authentication","title":"\ud83e\uddea Testing LDAP Authentication","text":""},{"location":"authentication/ldap-auth/#integration-tests","title":"Integration Tests","text":"<pre><code>@SpringBootTest\n@ActiveProfiles(\"ldap\")\n@TestPropertySource(properties = {\n    \"logging.level.org.springframework.ldap=DEBUG\"\n})\nclass LdapAuthenticationTest {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void shouldAuthenticateLdapAdminUser() {\n        // Test LDAP admin authentication\n        ResponseEntity&lt;Map&gt; response = restTemplate\n                .withBasicAuth(\"ldapadmin\", \"password\")\n                .getForEntity(\"/api/ldap/users\", Map.class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody().get(\"user\")).isEqualTo(\"ldapadmin\");\n    }\n\n    @Test\n    void shouldAuthenticateLdapRegularUser() {\n        // Test LDAP user authentication\n        ResponseEntity&lt;Map&gt; response = restTemplate\n                .withBasicAuth(\"ldapuser\", \"password\")\n                .getForEntity(\"/api/ldap/users\", Map.class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody().get(\"user\")).isEqualTo(\"ldapuser\");\n    }\n\n    @Test\n    void shouldDenyInvalidLdapCredentials() {\n        // Test invalid credentials\n        ResponseEntity&lt;Map&gt; response = restTemplate\n                .withBasicAuth(\"invalid\", \"invalid\")\n                .getForEntity(\"/api/ldap/users\", Map.class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);\n    }\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#ldap-connection-test","title":"LDAP Connection Test","text":"<pre><code>@Test\nvoid shouldConnectToLdapServer() {\n    LdapTemplate ldapTemplate = new LdapTemplate(contextSource());\n\n    // Test LDAP connection\n    List&lt;String&gt; users = ldapTemplate.search(\n            \"ou=people\",\n            \"(objectclass=person)\",\n            (AttributesMapper&lt;String&gt;) attrs -&gt; \n                    (String) attrs.get(\"uid\").get()\n    );\n\n    assertThat(users).contains(\"ldapadmin\", \"ldapuser\");\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#production-ldap-configuration","title":"\ud83d\udd27 Production LDAP Configuration","text":""},{"location":"authentication/ldap-auth/#active-directory-integration","title":"Active Directory Integration","text":"<pre><code># application-production.yml\nldap:\n  url: ldaps://ad.company.com:636\n  base: dc=company,dc=com\n  username: cn=service-account,ou=service-accounts,dc=company,dc=com\n  password: ${LDAP_SERVICE_PASSWORD}\n  user:\n    search-base: ou=users\n    search-filter: \"(sAMAccountName={0})\"\n  group:\n    search-base: ou=groups\n    search-filter: \"(member={0})\"\n    role-attribute: cn\n</code></pre>"},{"location":"authentication/ldap-auth/#ssltls-configuration","title":"SSL/TLS Configuration","text":"<pre><code>@Bean\npublic ContextSource contextSource() {\n    LdapContextSource context = new LdapContextSource();\n    context.setUrl(\"ldaps://ldap.company.com:636\");\n    context.setBase(\"dc=company,dc=com\");\n\n    // SSL configuration\n    context.setPooled(true);\n\n    Map&lt;String, Object&gt; baseEnvironment = new HashMap&lt;&gt;();\n    baseEnvironment.put(Context.SECURITY_PROTOCOL, \"ssl\");\n    baseEnvironment.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n\n    // Trust store configuration for SSL\n    System.setProperty(\"javax.net.ssl.trustStore\", \"/path/to/truststore.jks\");\n    System.setProperty(\"javax.net.ssl.trustStorePassword\", \"password\");\n\n    context.setBaseEnvironmentProperties(baseEnvironment);\n    context.afterPropertiesSet();\n\n    return context;\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#ldap-best-practices","title":"\u26a1 LDAP Best Practices","text":""},{"location":"authentication/ldap-auth/#dos","title":"\u2705 Do's","text":"<ol> <li>Use connection pooling - Configure LDAP connection pools</li> <li>Implement SSL/TLS - Secure LDAP communication (LDAPS)</li> <li>Use service accounts - Dedicated accounts for LDAP binding</li> <li>Cache user details - Cache LDAP lookups to reduce load</li> <li>Handle connection failures - Implement retry logic and fallbacks</li> </ol>"},{"location":"authentication/ldap-auth/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't store LDAP passwords in configuration files</li> <li>Don't ignore SSL certificate validation in production</li> <li>Don't perform excessive LDAP searches - optimize queries</li> <li>Don't hardcode LDAP DNs - use configuration properties</li> <li>Don't forget timeout configuration - set appropriate timeouts</li> </ol>"},{"location":"authentication/ldap-auth/#performance-optimization","title":"\ud83d\udd27 Performance Optimization","text":"<pre><code>@Bean\npublic LdapTemplate ldapTemplate() {\n    LdapTemplate template = new LdapTemplate(contextSource());\n\n    // Connection pool configuration\n    template.setDefaultCountLimit(1000);\n    template.setDefaultTimeLimit(5000);\n\n    return template;\n}\n\n// Caching LDAP user details\n@Cacheable(\"ldapUsers\")\npublic UserDetails loadUserByUsername(String username) {\n    return ldapUserDetailsService.loadUserByUsername(username);\n}\n</code></pre>"},{"location":"authentication/ldap-auth/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>OAuth2 Authentication \u2192 - Social login integration</li> <li>JWT Tokens \u2192 - Stateless authentication</li> <li>SSO Integration \u2192 - Enterprise single sign-on</li> <li>API Reference \u2192 - LDAP endpoints</li> <li>Security Configuration \u2192 - LDAP security setup</li> </ul> <p>\ud83c\udfe2 LDAP authentication provides enterprise-grade directory integration, enabling centralized user management and seamless integration with existing corporate infrastructure.</p>"},{"location":"authentication/oauth2-auth/","title":"OAuth2 Authentication","text":"<p>Comprehensive guide to OAuth2 authentication in Spring Security. Learn how to integrate with social login providers like Google, GitHub, and Facebook for modern authentication flows.</p>"},{"location":"authentication/oauth2-auth/#oauth2-overview","title":"\ud83c\udf10 OAuth2 Overview","text":"<p>OAuth2 enables secure third-party authentication without exposing user credentials to your application. Users authenticate with trusted providers and grant limited access to your app.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant A as Application\n    participant P as OAuth2 Provider\n    participant R as Resource Server\n\n    Note over U,R: OAuth2 Authorization Code Flow\n    U-&gt;&gt;A: Click \"Login with Provider\"\n    A-&gt;&gt;P: Redirect to authorization URL\n    U-&gt;&gt;P: Login with provider credentials\n    P-&gt;&gt;P: User grants permissions\n    P-&gt;&gt;A: Redirect with authorization code\n    A-&gt;&gt;P: Exchange code for access token\n    P--&gt;&gt;A: Access token + refresh token\n    A-&gt;&gt;R: Request user info with token\n    R--&gt;&gt;A: User profile data\n    A-&gt;&gt;A: Create user session\n    A--&gt;&gt;U: Authentication successful</code></pre>"},{"location":"authentication/oauth2-auth/#oauth2-configuration","title":"\ud83d\udd27 OAuth2 Configuration","text":""},{"location":"authentication/oauth2-auth/#oauth2-client-setup","title":"OAuth2 Client Setup","text":"<pre><code>@Configuration\n@EnableOAuth2Client\n@Profile(\"oauth2\")\npublic class OAuth2Config {\n\n    private static final Logger logger = LogManager.getLogger(OAuth2Config.class);\n\n    @Bean\n    public ClientRegistrationRepository clientRegistrationRepository() {\n        logger.info(\"\ud83c\udf10 [OAUTH2-CONFIG] Setting up OAuth2 client registrations\");\n        logger.debug(\"\ud83d\udcda [LEARNING] OAuth2 allows third-party authentication providers\");\n\n        return new InMemoryClientRegistrationRepository(\n                googleClientRegistration(),\n                githubClientRegistration(),\n                facebookClientRegistration()\n        );\n    }\n\n    @Bean\n    public OAuth2AuthorizedClientService authorizedClientService() {\n        return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository());\n    }\n\n    @Bean\n    public OAuth2AuthorizedClientManager authorizedClientManager() {\n        OAuth2AuthorizedClientProvider authorizedClientProvider =\n                OAuth2AuthorizedClientProviderBuilder.builder()\n                        .authorizationCode()\n                        .refreshToken()\n                        .build();\n\n        DefaultOAuth2AuthorizedClientManager authorizedClientManager =\n                new DefaultOAuth2AuthorizedClientManager(\n                        clientRegistrationRepository(),\n                        authorizedClientService()\n                );\n\n        authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n        logger.debug(\"\u2705 [OAUTH2-CONFIG] OAuth2 client manager configured\");\n\n        return authorizedClientManager;\n    }\n}\n</code></pre>"},{"location":"authentication/oauth2-auth/#oauth2-client-registrations","title":"OAuth2 Client Registrations","text":"<pre><code>private ClientRegistration googleClientRegistration() {\n    logger.debug(\"\ud83d\udd10 [OAUTH2-CONFIG] Configuring Google OAuth2 client\");\n\n    return ClientRegistration.withRegistrationId(\"google\")\n            .clientId(\"${oauth2.google.client-id}\")\n            .clientSecret(\"${oauth2.google.client-secret}\")\n            .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n            .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n            .scope(\"openid\", \"profile\", \"email\")\n            .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n            .tokenUri(\"https://oauth2.googleapis.com/token\")\n            .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n            .userNameAttributeName(IdTokenClaimNames.SUB)\n            .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n            .clientName(\"Google\")\n            .build();\n}\n\nprivate ClientRegistration githubClientRegistration() {\n    logger.debug(\"\ud83d\udd10 [OAUTH2-CONFIG] Configuring GitHub OAuth2 client\");\n\n    return ClientRegistration.withRegistrationId(\"github\")\n            .clientId(\"${oauth2.github.client-id}\")\n            .clientSecret(\"${oauth2.github.client-secret}\")\n            .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n            .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n            .scope(\"read:user\")\n            .authorizationUri(\"https://github.com/login/oauth/authorize\")\n            .tokenUri(\"https://github.com/login/oauth/access_token\")\n            .userInfoUri(\"https://api.github.com/user\")\n            .userNameAttributeName(\"id\")\n            .clientName(\"GitHub\")\n            .build();\n}\n\nprivate ClientRegistration facebookClientRegistration() {\n    logger.debug(\"\ud83d\udd10 [OAUTH2-CONFIG] Configuring Facebook OAuth2 client\");\n\n    return ClientRegistration.withRegistrationId(\"facebook\")\n            .clientId(\"${oauth2.facebook.client-id}\")\n            .clientSecret(\"${oauth2.facebook.client-secret}\")\n            .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_POST)\n            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n            .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n            .scope(\"email\", \"public_profile\")\n            .authorizationUri(\"https://www.facebook.com/v18.0/dialog/oauth\")\n            .tokenUri(\"https://graph.facebook.com/v18.0/oauth/access_token\")\n            .userInfoUri(\"https://graph.facebook.com/me?fields=id,name,email\")\n            .userNameAttributeName(\"id\")\n            .clientName(\"Facebook\")\n            .build();\n}\n</code></pre>"},{"location":"authentication/oauth2-auth/#security-configuration","title":"\ud83d\udd10 Security Configuration","text":""},{"location":"authentication/oauth2-auth/#oauth2-security-filter-chain","title":"OAuth2 Security Filter Chain","text":"<p>```java @Configuration @EnableWebSecurity @Profile(\"oauth2\") public class OAuth2SecurityConfig {</p> <pre><code>private static final Logger logger = LogManager.getLogger(OAuth2SecurityConfig.class);\n\n@Autowired\nprivate OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; customOAuth2UserService;\n\n@Bean\npublic SecurityFilterChain oauth2FilterChain(HttpSecurity http) throws Exception {\n    logger.info(\"\ud83d\udd10 [OAUTH2-SECURITY] Configuring OAuth2 security filter chain\");\n    logger.debug(\"\ud83d\udcda [LEARNING] OAuth2 login with social providers\");\n\n    return http\n        .authorizeHttpRequests(authz -&gt; authz\n            .requestMatchers(\"/\", \"/login\", \"/oauth2/**\", \"/api/public/**\").permitAll()\n            .requestMatchers(\"/api/oauth2/**\").authenticated()\n            .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n            .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n            .anyRequest().authenticated()\n        )\n\n        .oauth2Login(oauth2 -&gt; oauth2\n            .loginPage(\"/login\")\n            .defaultSuccessUrl(\"/api/oauth2/success\")\n            .failureUrl(\"/login?error\")\n            .userInfoEndpoint(userInfo -&gt; userInfo\n                .userService(customOAuth2UserService)\n            )\\n            )\\n            \\n            .logout(logout -&gt; logout\\n                .logoutUrl(\\\"/logout\\\")\\n                .logoutSuccessUrl(\\\"/\\\")\\n                .invalidateHttpSession(true)\\n                .clearAuthentication(true)\\n            )\\n            \\n            .sessionManagement(session -&gt; session\\n                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\\n                .maximumSessions(1)\\n                .maxSessionsPreventsLogin(false)\\n            )\\n            \\n            .csrf(csrf -&gt; csrf.disable())\\n            \\n            .build();\\n    }\\n}\\n```\\n\\n## \ud83c\udfaf **Custom OAuth2 User Service**\\n\\n### **OAuth2UserService Implementation**\\n\\n```java\\n@Service\\npublic class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {\\n    \\n    private static final Logger logger = LogManager.getLogger(CustomOAuth2UserService.class);\\n    \\n    private final DefaultOAuth2UserService delegate = new DefaultOAuth2UserService();\\n    \\n    @Override\\n    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {\\n        OAuth2User oauth2User = delegate.loadUser(userRequest);\\n        \\n        String registrationId = userRequest.getClientRegistration().getRegistrationId();\\n        String userNameAttributeName = userRequest.getClientRegistration()\\n                .getProviderDetails().getUserInfoEndpoint().getUserNameAttributeName();\\n                \\n        logger.info(\\\"\ud83c\udf10 [OAUTH2-USER] Loading OAuth2 user from provider: {}\\\", registrationId);\\n        logger.debug(\\\"\ud83d\udcca [OAUTH2-USER] User name attribute: {}\\\", userNameAttributeName);\\n        \\n        // Extract user information based on provider\\n        OAuth2UserInfo userInfo = OAuth2UserInfoFactory.getOAuth2UserInfo(\\n                registrationId, \\n                oauth2User.getAttributes()\\n        );\\n        \\n        logger.debug(\\\"\ud83d\udc64 [OAUTH2-USER] User info extracted:\\\");\\n        logger.debug(\\\"   \u2022 ID: {}\\\", userInfo.getId());\\n        logger.debug(\\\"   \u2022 Name: {}\\\", userInfo.getName());\\n        logger.debug(\\\"   \u2022 Email: {}\\\", userInfo.getEmail());\\n        \\n        // Check if user exists in database, create if not\\n        User user = createOrUpdateUser(userInfo, registrationId);\\n        \\n        // Create custom principal with user details\\n        return new CustomOAuth2User(\\n                oauth2User.getAuthorities(),\\n                oauth2User.getAttributes(),\\n                userNameAttributeName,\\n                user\\n        );\\n    }\\n    \\n    private User createOrUpdateUser(OAuth2UserInfo userInfo, String provider) {\\n        logger.debug(\\\"\ud83d\udd04 [OAUTH2-USER] Creating/updating user for provider: {}\\\", provider);\\n        \\n        // Implementation for user creation/update logic\\n        User user = User.builder()\\n                .providerId(userInfo.getId())\\n                .provider(provider)\\n                .name(userInfo.getName())\\n                .email(userInfo.getEmail())\\n                .role(\\\"ROLE_USER\\\") // Default role\\n                .enabled(true)\\n                .build();\\n                \\n        logger.debug(\\\"\u2705 [OAUTH2-USER] User created/updated successfully\\\");\\n        return user;\\n    }\\n}\\n```\\n\\n### **OAuth2 User Info Factory**\\n\\n```java\\npublic class OAuth2UserInfoFactory {\\n    \\n    public static OAuth2UserInfo getOAuth2UserInfo(String registrationId, \\n                                                   Map&lt;String, Object&gt; attributes) {\\n        \\n        return switch (registrationId.toLowerCase()) {\\n            case \\\"google\\\" -&gt; new GoogleOAuth2UserInfo(attributes);\\n            case \\\"github\\\" -&gt; new GitHubOAuth2UserInfo(attributes);\\n            case \\\"facebook\\\" -&gt; new FacebookOAuth2UserInfo(attributes);\\n            default -&gt; throw new OAuth2AuthenticationProcessingException(\\n                    \\\"Login with \\\" + registrationId + \\\" is not supported\\\");\\n        };\\n    }\\n}\\n\\n// Provider-specific user info classes\\npublic class GoogleOAuth2UserInfo extends OAuth2UserInfo {\\n    \\n    public GoogleOAuth2UserInfo(Map&lt;String, Object&gt; attributes) {\\n        super(attributes);\\n    }\\n    \\n    @Override\\n    public String getId() {\\n        return (String) attributes.get(\\\"sub\\\");\\n    }\\n    \\n    @Override\\n    public String getName() {\\n        return (String) attributes.get(\\\"name\\\");\\n    }\\n    \\n    @Override\\n    public String getEmail() {\\n        return (String) attributes.get(\\\"email\\\");\\n    }\\n    \\n    @Override\\n    public String getImageUrl() {\\n        return (String) attributes.get(\\\"picture\\\");\\n    }\\n}\\n```\\n\\n## \ud83d\ude80 **Usage Examples**\\n\\n### **1. OAuth2 Login Endpoints**\\n\\n```bash\\n# Initiate Google OAuth2 login\\ncurl -v http://localhost:8080/oauth2/authorization/google\\n\\n# Initiate GitHub OAuth2 login\\ncurl -v http://localhost:8080/oauth2/authorization/github\\n\\n# Initiate Facebook OAuth2 login\\ncurl -v http://localhost:8080/oauth2/authorization/facebook\\n```\\n\\n### **2. OAuth2 User Info Endpoint**\\n\\n```java\\n@RestController\\n@RequestMapping(\\\"/api/oauth2\\\")\\npublic class OAuth2Controller {\\n    \\n    @GetMapping(\\\"/user\\\")\\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getCurrentUser(\\n            @AuthenticationPrincipal OAuth2User principal) {\\n        \\n        Map&lt;String, Object&gt; userInfo = new HashMap&lt;&gt;();\\n        userInfo.put(\\\"name\\\", principal.getAttribute(\\\"name\\\"));\\n        userInfo.put(\\\"email\\\", principal.getAttribute(\\\"email\\\"));\\n        userInfo.put(\\\"provider\\\", getProvider(principal));\\n        userInfo.put(\\\"authorities\\\", principal.getAuthorities());\\n        \\n        return ResponseEntity.ok(userInfo);\\n    }\\n    \\n    @GetMapping(\\\"/success\\\")\\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; loginSuccess(\\n            Authentication authentication) {\\n            \\n        OAuth2User oauth2User = (OAuth2User) authentication.getPrincipal();\\n        \\n        return ResponseEntity.ok(Map.of(\\n            \\\"message\\\", \\\"OAuth2 login successful\\\",\\n            \\\"user\\\", oauth2User.getAttribute(\\\"name\\\"),\\n            \\\"email\\\", oauth2User.getAttribute(\\\"email\\\"),\\n            \\\"provider\\\", getProvider(oauth2User)\\n        ));\\n    }\\n}\\n```\\n\\n### **3. OAuth2 Response Example**\\n\\n```json\\n{\\n  \\\"message\\\": \\\"OAuth2 login successful\\\",\\n  \\\"user\\\": \\\"John Doe\\\",\\n  \\\"email\\\": \\\"john.doe@example.com\\\",\\n  \\\"provider\\\": \\\"google\\\",\\n  \\\"authorities\\\": [\\n    {\\n      \\\"authority\\\": \\\"ROLE_USER\\\"\\n    },\\n    {\\n      \\\"authority\\\": \\\"OAUTH2_USER\\\"\\n    }\\n  ],\\n  \\\"attributes\\\": {\\n    \\\"sub\\\": \\\"123456789\\\",\\n    \\\"name\\\": \\\"John Doe\\\",\\n    \\\"email\\\": \\\"john.doe@example.com\\\",\\n    \\\"picture\\\": \\\"https://example.com/avatar.jpg\\\"\\n  }\\n}\\n```\\n\\n## \ud83d\udd27 **Configuration Properties**\\n\\n### **Application Properties**\\n\\n```yaml\\n# application-oauth2.yml\\nspring:\\n  security:\\n    oauth2:\\n      client:\\n        registration:\\n          google:\\n            client-id: ${GOOGLE_CLIENT_ID}\\n            client-secret: ${GOOGLE_CLIENT_SECRET}\\n            scope:\\n              - openid\\n              - profile\\n              - email\\n            redirect-uri: \\\"{baseUrl}/login/oauth2/code/{registrationId}\\\"\\n          \\n          github:\\n            client-id: ${GITHUB_CLIENT_ID}\\n            client-secret: ${GITHUB_CLIENT_SECRET}\\n            scope:\\n              - read:user\\n              - user:email\\n            redirect-uri: \\\"{baseUrl}/login/oauth2/code/{registrationId}\\\"\\n          \\n          facebook:\\n            client-id: ${FACEBOOK_CLIENT_ID}\\n            client-secret: ${FACEBOOK_CLIENT_SECRET}\\n            scope:\\n              - email\\n              - public_profile\\n            redirect-uri: \\\"{baseUrl}/login/oauth2/code/{registrationId}\\\"\\n        \\n        provider:\\n          facebook:\\n            authorization-uri: https://www.facebook.com/v18.0/dialog/oauth\\n            token-uri: https://graph.facebook.com/v18.0/oauth/access_token\\n            user-info-uri: https://graph.facebook.com/me?fields=id,name,email\\n            user-name-attribute: id\\n\\nlogging:\\n  level:\\n    org.springframework.security.oauth2: DEBUG\\n    com.example.oauth2: DEBUG\\n```\\n\\n## \ud83e\uddea **Testing OAuth2 Authentication**\\n\\n### **Integration Tests**\\n\\n```java\\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\\n@ActiveProfiles(\\\"oauth2\\\")\\nclass OAuth2AuthenticationTest {\\n    \\n    @Autowired\\n    private TestRestTemplate restTemplate;\\n    \\n    @Autowired\\n    private ClientRegistrationRepository clientRegistrationRepository;\\n    \\n    @Test\\n    void shouldHaveOAuth2ClientRegistrations() {\\n        // Test OAuth2 client registrations are configured\\n        ClientRegistration google = clientRegistrationRepository.findByRegistrationId(\\\"google\\\");\\n        ClientRegistration github = clientRegistrationRepository.findByRegistrationId(\\\"github\\\");\\n        ClientRegistration facebook = clientRegistrationRepository.findByRegistrationId(\\\"facebook\\\");\\n        \\n        assertThat(google).isNotNull();\\n        assertThat(github).isNotNull();\\n        assertThat(facebook).isNotNull();\\n        \\n        assertThat(google.getClientName()).isEqualTo(\\\"Google\\\");\\n        assertThat(github.getClientName()).isEqualTo(\\\"GitHub\\\");\\n        assertThat(facebook.getClientName()).isEqualTo(\\\"Facebook\\\");\\n    }\\n    \\n    @Test\\n    void shouldRedirectToOAuth2Provider() {\\n        // Test OAuth2 authorization redirection\\n        ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(\\n                \\\"/oauth2/authorization/google\\\", \\n                String.class\\n        );\\n        \\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.FOUND);\\n        assertThat(response.getHeaders().getLocation().toString())\\n                .contains(\\\"accounts.google.com/o/oauth2/v2/auth\\\");\\n    }\\n}\\n```\\n\\n### **Mock OAuth2 User Tests**\\n\\n```java\\n@Test\\n@WithMockOAuth2User(value = \\\"123456789\\\", attributes = {\\n    \\\"sub\\\", \\\"123456789\\\",\\n    \\\"name\\\", \\\"Test User\\\",\\n    \\\"email\\\", \\\"test@example.com\\\"\\n})\\nvoid shouldAuthenticateWithMockOAuth2User() {\\n    ResponseEntity&lt;Map&gt; response = restTemplate.getForEntity(\\n            \\\"/api/oauth2/user\\\", \\n            Map.class\\n    );\\n    \\n    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\\n    assertThat(response.getBody().get(\\\"name\\\")).isEqualTo(\\\"Test User\\\");\\n    assertThat(response.getBody().get(\\\"email\\\")).isEqualTo(\\\"test@example.com\\\");\\n}\\n```\\n\\n## \ud83d\udd04 **OAuth2 Token Management**\\n\\n### **Token Refresh**\\n\\n```java\\n@Component\\npublic class OAuth2TokenRefreshService {\\n    \\n    private final OAuth2AuthorizedClientManager authorizedClientManager;\\n    \\n    public String refreshAccessToken(String clientRegistrationId, String principalName) {\\n        OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest\\n                .withClientRegistrationId(clientRegistrationId)\\n                .principal(principalName)\\n                .build();\\n                \\n        OAuth2AuthorizedClient authorizedClient = \\n                authorizedClientManager.authorize(authorizeRequest);\\n                \\n        if (authorizedClient != null &amp;&amp; authorizedClient.getAccessToken() != null) {\\n            return authorizedClient.getAccessToken().getTokenValue();\\n        }\\n        \\n        throw new IllegalStateException(\\\"Unable to refresh OAuth2 token\\\");\\n    }\\n}\\n```\\n\\n### **Token Storage**\\n\\n```java\\n@Bean\\npublic OAuth2AuthorizedClientService authorizedClientService() {\\n    // Use JdbcOAuth2AuthorizedClientService for persistent token storage\\n    return new JdbcOAuth2AuthorizedClientService(\\n            jdbcTemplate,\\n            clientRegistrationRepository()\\n    );\\n}\\n```\\n\\n## \u26a1 **OAuth2 Best Practices**\\n\\n### **\u2705 Do's**\\n\\n1. **Use HTTPS in production** - OAuth2 requires secure communication\\n2. **Validate redirect URIs** - Prevent authorization code interception\\n3. **Implement proper scopes** - Request minimal required permissions\\n4. **Store tokens securely** - Use encrypted storage for access/refresh tokens\\n5. **Handle token expiration** - Implement automatic token refresh\\n\\n### **\u274c Don'ts**\\n\\n1. **Don't store client secrets** in source code or client-side applications\\n2. **Don't use implicit flow** - Use authorization code flow with PKCE\\n3. **Don't ignore state parameters** - Prevent CSRF attacks\\n4. **Don't trust client-side tokens** - Always validate tokens server-side\\n5. **Don't expose sensitive scopes** - Limit access to necessary data only\\n\\n### **\ud83d\udd27 Production Configuration**\\n\\n```yaml\\n# application-production.yml\\nspring:\\n  security:\\n    oauth2:\\n      client:\\n        registration:\\n          google:\\n            client-id: ${GOOGLE_OAUTH2_CLIENT_ID}\\n            client-secret: ${GOOGLE_OAUTH2_CLIENT_SECRET}\\n            \\nlogging:\\n  level:\\n    org.springframework.security.oauth2: INFO # Reduce debug logging\\n    \\n# Environment variables for production\\n# GOOGLE_OAUTH2_CLIENT_ID=your-google-client-id\\n# GOOGLE_OAUTH2_CLIENT_SECRET=your-google-client-secret\\n# GITHUB_OAUTH2_CLIENT_ID=your-github-client-id\\n# GITHUB_OAUTH2_CLIENT_SECRET=your-github-client-secret\\n```\\n\\n## \ud83d\ude80 **Next Steps**\\n\\n- **[SSO Integration \u2192](sso-integration.md)** - Enterprise single sign-on\\n- **[JWT Tokens \u2192](jwt-tokens.md)** - Combine OAuth2 with JWT\\n- **[LDAP Authentication \u2192](ldap-auth.md)** - Directory-based authentication\\n- **[API Reference \u2192](../api/auth-flow.md)** - OAuth2 API patterns\\n- **[Security Configuration \u2192](../security/index.md)** - OAuth2 security setup\\n\\n---\\n\\n**\ud83c\udf10 OAuth2 authentication enables modern social login flows while maintaining security and user privacy. Understanding provider integration and token management is essential for contemporary web applications.**\n</code></pre>"},{"location":"authentication/sso-integration/","title":"SSO Integration","text":"<p>Comprehensive guide to Single Sign-On (SSO) integration in Spring Security. Learn how to enable seamless authentication across multiple applications using SAML, OAuth2, or OpenID Connect.</p>"},{"location":"authentication/sso-integration/#sso-overview","title":"\ud83d\udd11 SSO Overview","text":"<p>Single Sign-On (SSO) allows users to authenticate once and gain access to multiple independent systems without repeated logins. SSO is commonly implemented using protocols like SAML, OAuth2, or OpenID Connect.</p> <pre><code>sequenceDiagram\n    participant U as User\n    participant SP as Service Provider\n    participant IdP as Identity Provider\n    participant App as Application\n\n    Note over U,App: SSO Authentication Flow\n    U-&gt;&gt;SP: Access protected resource\n    SP-&gt;&gt;IdP: Redirect to IdP for authentication\n    U-&gt;&gt;IdP: Login with credentials\n    IdP-&gt;&gt;SP: SSO assertion (SAML/OIDC)\n    SP-&gt;&gt;App: Pass user identity\n    App--&gt;&gt;U: Grant access</code></pre>"},{"location":"authentication/sso-integration/#sso-implementation-patterns","title":"\ud83d\udd27 SSO Implementation Patterns","text":""},{"location":"authentication/sso-integration/#1-saml-sso-integration","title":"1. SAML SSO Integration","text":"<ul> <li>Use Spring Security SAML extension for SAML 2.0 support</li> <li>Configure Service Provider (SP) and Identity Provider (IdP) metadata</li> <li>Handle SAML assertions and map user roles</li> </ul>"},{"location":"authentication/sso-integration/#2-oauth2openid-connect-sso","title":"2. OAuth2/OpenID Connect SSO","text":"<ul> <li>Use Spring Security OAuth2 client for OIDC flows</li> <li>Configure trusted IdP (e.g., Azure AD, Google Workspace)</li> <li>Map OIDC claims to application roles</li> </ul>"},{"location":"authentication/sso-integration/#security-configuration-example","title":"\ud83d\udd10 Security Configuration Example","text":""},{"location":"authentication/sso-integration/#saml-sso-filter-chain","title":"SAML SSO Filter Chain","text":"<pre><code>@Configuration\n@EnableWebSecurity\n@Profile(\"sso\")\npublic class SsoSecurityConfig {\n    @Bean\n    public SecurityFilterChain ssoFilterChain(HttpSecurity http) throws Exception {\n        return http\n            .authorizeHttpRequests(authz -&gt; authz\n                .requestMatchers(\"/sso/**\").authenticated()\n                .anyRequest().permitAll()\n            )\n            .saml2Login(saml2 -&gt; saml2\n                .loginPage(\"/sso/login\")\n                .defaultSuccessUrl(\"/sso/success\")\n            )\n            .build();\n    }\n}\n</code></pre>"},{"location":"authentication/sso-integration/#oidc-sso-filter-chain","title":"OIDC SSO Filter Chain","text":"<pre><code>@Configuration\n@EnableWebSecurity\n@Profile(\"sso-oidc\")\npublic class OidcSsoSecurityConfig {\n    @Bean\n    public SecurityFilterChain oidcSsoFilterChain(HttpSecurity http) throws Exception {\n        return http\n            .authorizeHttpRequests(authz -&gt; authz\n                .requestMatchers(\"/sso/**\").authenticated()\n                .anyRequest().permitAll()\n            )\n            .oauth2Login(oauth2 -&gt; oauth2\n                .loginPage(\"/sso/login\")\n                .defaultSuccessUrl(\"/sso/success\")\n            )\n            .build();\n    }\n}\n</code></pre>"},{"location":"authentication/sso-integration/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"authentication/sso-integration/#1-sso-login-endpoint","title":"1. SSO Login Endpoint","text":"<pre><code>curl -v http://localhost:8080/sso/login\n</code></pre>"},{"location":"authentication/sso-integration/#2-sso-success-endpoint","title":"2. SSO Success Endpoint","text":"<pre><code>@RestController\n@RequestMapping(\"/sso\")\npublic class SsoController {\n    @GetMapping(\"/success\")\n    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; ssoSuccess(Authentication authentication) {\n        Map&lt;String, Object&gt; userInfo = new HashMap&lt;&gt;();\n        userInfo.put(\"name\", authentication.getName());\n        userInfo.put(\"authorities\", authentication.getAuthorities());\n        userInfo.put(\"details\", authentication.getDetails());\n        return ResponseEntity.ok(userInfo);\n    }\n}\n</code></pre>"},{"location":"authentication/sso-integration/#testing-sso-integration","title":"\ud83e\uddea Testing SSO Integration","text":"<ul> <li>Use SAML/OIDC test IdPs (e.g., SSOCircle, Google Workspace)</li> <li>Validate SSO login, role mapping, and session propagation</li> </ul>"},{"location":"authentication/sso-integration/#sso-best-practices","title":"\u26a1 SSO Best Practices","text":""},{"location":"authentication/sso-integration/#dos","title":"\u2705 Do's","text":"<ol> <li>Use trusted identity providers (IdPs)</li> <li>Map SSO claims to application roles</li> <li>Implement session timeout and logout propagation</li> <li>Use HTTPS for all SSO endpoints</li> <li>Log SSO authentication events for auditing</li> </ol>"},{"location":"authentication/sso-integration/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't hardcode IdP credentials</li> <li>Don't ignore SSO assertion validation</li> <li>Don't expose sensitive SSO endpoints</li> <li>Don't skip logout propagation</li> </ol>"},{"location":"authentication/sso-integration/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>JWT Tokens \u2192 - Combine SSO with JWT for distributed systems</li> <li>OAuth2 Authentication \u2192 - Social login integration</li> <li>LDAP Authentication \u2192 - Directory-based authentication</li> <li>API Reference \u2192 - SSO API patterns</li> <li>Security Configuration \u2192 - SSO security setup</li> </ul> <p>\ud83d\udd11 SSO integration enables seamless authentication across multiple applications, improving user experience and security. Understanding SAML, OAuth2, and OIDC patterns is essential for enterprise-grade identity management.</p>"},{"location":"deployment/","title":"Deployment Overview","text":"<p>This is a placeholder for deployment overview documentation.</p>"},{"location":"deployment/production/","title":"Production Deployment","text":"<p>This is a placeholder for production deployment documentation.</p>"},{"location":"deployment/profiles/","title":"Configuration Profiles","text":"<p>This is a placeholder for configuration profiles documentation.</p>"},{"location":"examples/advanced-patterns/","title":"Advanced Patterns","text":"<p>This is a placeholder for advanced security patterns documentation.</p>"},{"location":"examples/custom-providers/","title":"Custom Providers","text":"<p>This is a placeholder for custom authentication providers documentation.</p>"},{"location":"examples/testing-auth/","title":"Testing Authentication","text":"<p>This is a placeholder for authentication testing documentation.</p>"},{"location":"getting-started/overview/","title":"Project Overview","text":"<p>The Spring Security Reference Project is a comprehensive educational resource designed to demonstrate modern Spring Security patterns and best practices. This project showcases multiple authentication methods, security configurations, and real-world implementation patterns.</p>"},{"location":"getting-started/overview/#learning-objectives","title":"\ud83c\udfaf Learning Objectives","text":"<p>After working through this project, you will understand:</p> <ul> <li>Multiple Authentication Strategies: How to implement and integrate different authentication methods</li> <li>Security Filter Chains: How Spring Security processes requests and applies security rules</li> <li>JWT Token Management: Stateless authentication with JSON Web Tokens</li> <li>Role-Based Access Control: Implementing fine-grained authorization</li> <li>Integration Patterns: Combining multiple authentication providers</li> <li>Security Best Practices: Production-ready security configurations</li> </ul>"},{"location":"getting-started/overview/#architecture-philosophy","title":"\ud83c\udfdb\ufe0f Architecture Philosophy","text":"<p>This project follows a modular layered architecture with clear separation of concerns:</p>"},{"location":"getting-started/overview/#design-principles","title":"Design Principles","text":"<ol> <li>Modularity: Each authentication method is isolated in its own module</li> <li>Educational Focus: Comprehensive logging explains every security decision</li> <li>Real-world Patterns: Configurations mirror production environments</li> <li>Testability: Each module can be tested independently</li> <li>Extensibility: Easy to add new authentication methods</li> </ol>"},{"location":"getting-started/overview/#module-dependencies","title":"Module Dependencies","text":"<pre><code>graph LR\n    A[rest-api] --&gt; B[common-security]\n    A --&gt; C[common-auth]\n    A --&gt; D[jdbc-auth]\n    A --&gt; E[ldap-auth] \n    A --&gt; F[oauth2-auth]\n    A --&gt; G[authorization-service]\n\n    B --&gt; C\n\n    classDef coreModule fill:#e1f5fe\n    classDef authModule fill:#f3e5f5\n    classDef serviceModule fill:#e8f5e8\n\n    class A,B,C serviceModule\n    class D,E,F authModule\n    class G coreModule</code></pre>"},{"location":"getting-started/overview/#security-patterns-demonstrated","title":"\ud83d\udd12 Security Patterns Demonstrated","text":""},{"location":"getting-started/overview/#1-authentication-methods","title":"1. Authentication Methods","text":"Method Module Use Case Educational Focus JDBC <code>jdbc-auth</code> Database-backed users User stores, password encoding LDAP <code>ldap-auth</code> Enterprise directories Directory integration, attribute mapping OAuth2 <code>oauth2-auth</code> Social login, SSO Modern identity protocols, token handling JWT <code>common-auth</code> Stateless APIs Token generation, validation, claims"},{"location":"getting-started/overview/#2-security-configurations","title":"2. Security Configurations","text":"<ul> <li>Filter Chain Setup: Custom security filter ordering</li> <li>Method Security: Annotation-based authorization</li> <li>CORS Configuration: Cross-origin request handling  </li> <li>Session Management: Stateful vs stateless strategies</li> </ul>"},{"location":"getting-started/overview/#3-advanced-patterns","title":"3. Advanced Patterns","text":"<ul> <li>Multi-Provider Authentication: Combining different auth methods</li> <li>Custom Authentication Providers: Building tailored auth logic</li> <li>Security Context Management: Handling authenticated users</li> <li>Exception Handling: Graceful security error responses</li> </ul>"},{"location":"getting-started/overview/#request-flow","title":"\ud83d\udcca Request Flow","text":"<p>Understanding how requests flow through the security system:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant F as Security Filter Chain\n    participant A as Auth Provider\n    participant S as Service Layer\n    participant D as Data Layer\n\n    C-&gt;&gt;F: HTTP Request\n    F-&gt;&gt;F: Extract Credentials\n    F-&gt;&gt;A: Authenticate User\n    A-&gt;&gt;D: Validate Credentials\n    D--&gt;&gt;A: User Details\n    A--&gt;&gt;F: Authentication Result\n    F-&gt;&gt;S: Authorized Request\n    S--&gt;&gt;C: Response</code></pre>"},{"location":"getting-started/overview/#educational-features","title":"\ud83c\udf93 Educational Features","text":""},{"location":"getting-started/overview/#comprehensive-logging","title":"Comprehensive Logging","text":"<p>Every security operation includes educational logging:</p> <pre><code>logger.info(\"\ud83d\udd10 [JDBC-AUTH] Creating BCrypt password encoder for database users\");\nlogger.debug(\"\ud83d\udcda [LEARNING] BCrypt adds salt and hashing for secure password storage\");\nlogger.debug(\"\ud83d\udd04 [LEARNING] Authentication flow: request \u2192 provider \u2192 userDetailsService \u2192 passwordEncoder\");\n</code></pre>"},{"location":"getting-started/overview/#learning-annotations","title":"Learning Annotations","text":"<p>Code comments explain Spring Security concepts:</p> <pre><code>/**\n * Educational Logging: This configuration demonstrates directory-based authentication\n * with comprehensive logging for enterprise learning scenarios.\n * \n * This configuration demonstrates:\n * - Embedded LDAP server setup for development/testing\n * - LDAP bind authentication (user provides credentials, LDAP verifies)\n * - LDAP-based authority/role population from groups\n */\n</code></pre>"},{"location":"getting-started/overview/#testing-examples","title":"Testing Examples","text":"<p>Complete HTTP test files demonstrate:</p> <ul> <li>Authentication flows for each method</li> <li>Role-based endpoint access</li> <li>Error handling scenarios</li> <li>Token lifecycle management</li> </ul>"},{"location":"getting-started/overview/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Ready to dive in? Follow these paths based on your learning goals:</p>"},{"location":"getting-started/overview/#for-beginners","title":"For Beginners","text":"<ol> <li>Quick Setup - Get the project running</li> <li>Project Structure - Understand the codebase</li> <li>JDBC Authentication - Start with database auth</li> </ol>"},{"location":"getting-started/overview/#for-intermediate-users","title":"For Intermediate Users","text":"<ol> <li>Security Configuration - Understand security setup</li> <li>JWT Tokens - Learn stateless authentication</li> <li>API Testing - Practice with endpoints</li> </ol>"},{"location":"getting-started/overview/#for-advanced-users","title":"For Advanced Users","text":"<ol> <li>Custom Providers - Build custom auth logic</li> <li>Advanced Patterns - Complex security scenarios</li> <li>Production Setup - Deploy securely</li> </ol>"},{"location":"getting-started/overview/#next-steps","title":"\ud83d\udd17 Next Steps","text":"<p>Continue your learning journey:</p> <ul> <li>Quick Setup \u2192 Set up your development environment</li> <li>Project Structure \u2192 Explore the codebase organization</li> </ul>"},{"location":"getting-started/project-structure/","title":"Project Structure","text":"<p>This page explains the modular architecture and folder structure of the Spring Security Reference project.</p>"},{"location":"getting-started/project-structure/#overview","title":"\ud83c\udfd7\ufe0f Overview","text":"<p>The project uses a layered modular architecture for clear separation of concerns:</p> <pre><code>api-service \u2192 common-auth + common-security + authorization-service\ncommon-security \u2192 common-auth\nauthorization-service \u2192 standalone\ncommon-auth \u2192 standalone\n</code></pre>"},{"location":"getting-started/project-structure/#folder-layout","title":"\ud83d\udcc1 Folder Layout","text":"<pre><code>README.md\napi-service/\n    README.md\n    src/main/java/com/example/apiservice/ApiController.java\nauthorization-service/\n    README.md\n    src/main/java/com/example/authorizationservice/AuthorizationService.java\ncommon-auth/\n    README.md\n    src/main/java/com/example/commonauth/\n        AuthService.java\n        CustomAuthenticationProvider.java\n        JwtAuthenticationFilter.java\n        JwtTokenUtil.java\n        TwoFactorAuthService.java\ncommon-security/\n    README.md\n    src/main/java/com/example/commonsecurity/\n        GrpcSecurityInterceptor.java\n        SecurityConfig.java\n        WebSocketSecurityInterceptor.java\ngraphql-service/\n    README.md\n    src/main/java/com/example/graphqlservice/\n        GraphQLController.java\n        GraphQLSecurityInterceptor.java\n</code></pre>"},{"location":"getting-started/project-structure/#module-responsibilities","title":"\ud83e\udde9 Module Responsibilities","text":"<ul> <li>api-service: REST endpoints, integrates authentication and authorization</li> <li>common-auth: Authentication logic (session, JWT, 2FA)</li> <li>common-security: Security configuration, filters, interceptors</li> <li>authorization-service: Role and permission management</li> <li>graphql-service: Scaffold for future GraphQL API and security integration</li> </ul>"},{"location":"getting-started/project-structure/#authentication-methods-api-types","title":"\ud83d\udd17 Authentication Methods &amp; API Types","text":"<ul> <li>Session-based: CustomAuthenticationProvider, AuthService</li> <li>JWT-based: JwtAuthenticationFilter, JwtTokenUtil</li> <li>LDAP: LdapAuthenticationProvider (see authentication/ldap-auth.md)</li> <li>OAuth2: OAuth2 client (see authentication/oauth2-auth.md)</li> <li>SSO: SAML/OIDC integration (see authentication/sso-integration.md)</li> <li>WebSocket: WebSocketSecurityInterceptor (see common-security)</li> <li>gRPC: GrpcSecurityInterceptor (see common-security)</li> <li>GraphQL: GraphQLController, GraphQLSecurityInterceptor (see graphql-service)</li> </ul>"},{"location":"getting-started/project-structure/#security-patterns","title":"\ud83d\udee1\ufe0f Security Patterns","text":"<ul> <li>All authentication flows converge through SecurityConfig filter chain</li> <li>Role-based access via AuthorizationService</li> <li>JWT tokens include username and role claims</li> <li>SecurityContextHolder used for downstream authorization</li> </ul>"},{"location":"getting-started/project-structure/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Quick Setup \u2192</li> <li>Authentication Methods \u2192</li> <li>API Reference \u2192</li> <li>Security Configuration \u2192</li> </ul> <p>This modular structure demonstrates best practices for scalable, secure Spring applications and is designed for easy extension to WebSocket, gRPC, and GraphQL APIs as you continue learning.</p>"},{"location":"getting-started/quick-setup/","title":"Quick Setup","text":"<p>Get the Spring Security Reference Project running on your local machine in just a few minutes.</p>"},{"location":"getting-started/quick-setup/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> Tool Version Purpose Java 17+ Runtime environment Maven 3.6+ Build and dependency management Git Latest Version control IDE IntelliJ IDEA, Eclipse, or VS Code Development environment"},{"location":"getting-started/quick-setup/#verify-prerequisites","title":"Verify Prerequisites","text":"<pre><code># Check Java version\njava -version\n\n# Check Maven version  \nmvn -version\n\n# Check Git version\ngit --version\n</code></pre>"},{"location":"getting-started/quick-setup/#installation","title":"\ud83d\ude80 Installation","text":""},{"location":"getting-started/quick-setup/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone &lt;repository-url&gt;\ncd spring-security-reference\n</code></pre>"},{"location":"getting-started/quick-setup/#2-build-the-project","title":"2. Build the Project","text":"<pre><code># Clean install all modules\nmvn clean install\n\n# Verify build success\necho \"Build completed successfully!\"\n</code></pre>"},{"location":"getting-started/quick-setup/#3-run-the-application","title":"3. Run the Application","text":"<pre><code># Start the main application\nmvn spring-boot:run -pl rest-api\n</code></pre> <p>The application will start on <code>http://localhost:8080</code></p>"},{"location":"getting-started/quick-setup/#verify-installation","title":"\u2705 Verify Installation","text":""},{"location":"getting-started/quick-setup/#test-public-endpoint","title":"Test Public Endpoint","text":"<pre><code>curl http://localhost:8080/api/public/hello\n</code></pre> <p>Expected response: <pre><code>Hello, world! (public endpoint - no authentication required)\n</code></pre></p>"},{"location":"getting-started/quick-setup/#test-authentication","title":"Test Authentication","text":"<pre><code># Get JWT token\ncurl -X POST http://localhost:8080/api/auth/login \\\n  -d \"username=admin&amp;password=password\"\n</code></pre> <p>Expected response: <pre><code>{\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"username\": \"admin\",\n  \"role\": \"ROLE_ADMIN\",\n  \"message\": \"Login successful - use this JWT token for authenticated requests\",\n  \"usage\": \"Add header: Authorization: Bearer &lt;token&gt;\"\n}\n</code></pre></p>"},{"location":"getting-started/quick-setup/#test-secured-endpoint","title":"Test Secured Endpoint","text":"<pre><code># Use the token from previous step\ncurl -H \"Authorization: Bearer &lt;your-jwt-token&gt;\" \\\n  http://localhost:8080/api/admin/secure\n</code></pre> <p>Expected response: <pre><code>{\n  \"message\": \"Hello, Admin! (secured endpoint)\",\n  \"user\": \"admin\",\n  \"authorities\": [\"ROLE_ADMIN\"],\n  \"authType\": \"JWT\"\n}\n</code></pre></p>"},{"location":"getting-started/quick-setup/#development-setup","title":"\ud83d\udd27 Development Setup","text":""},{"location":"getting-started/quick-setup/#ide-configuration","title":"IDE Configuration","text":""},{"location":"getting-started/quick-setup/#intellij-idea","title":"IntelliJ IDEA","text":"<ol> <li>Import Project: File \u2192 Open \u2192 Select <code>pom.xml</code></li> <li>Enable Annotation Processing: Settings \u2192 Build \u2192 Compiler \u2192 Annotation Processors</li> <li>Set JDK: File \u2192 Project Structure \u2192 Project \u2192 SDK: Java 17+</li> </ol>"},{"location":"getting-started/quick-setup/#eclipse","title":"Eclipse","text":"<ol> <li>Import Project: File \u2192 Import \u2192 Existing Maven Projects</li> <li>Select Root Directory: Browse to project folder</li> <li>Configure JDK: Right-click project \u2192 Properties \u2192 Java Build Path</li> </ol>"},{"location":"getting-started/quick-setup/#vs-code","title":"VS Code","text":"<ol> <li>Open Folder: File \u2192 Open Folder \u2192 Select project directory</li> <li>Install Extensions:</li> <li>Extension Pack for Java</li> <li>Spring Boot Extension Pack</li> <li>Configure Java: Ctrl+Shift+P \u2192 \"Java: Configure Runtime\"</li> </ol>"},{"location":"getting-started/quick-setup/#environment-variables","title":"Environment Variables","text":"<p>Set up optional environment variables for customization:</p> <pre><code># Application port (default: 8080)\nexport SERVER_PORT=8080\n\n# Active profiles (default: default)\nexport SPRING_PROFILES_ACTIVE=default\n\n# Log level (default: INFO)\nexport LOGGING_LEVEL_ROOT=INFO\n</code></pre>"},{"location":"getting-started/quick-setup/#testing-setup","title":"\ud83e\uddea Testing Setup","text":""},{"location":"getting-started/quick-setup/#run-all-tests","title":"Run All Tests","text":"<pre><code># Execute all unit and integration tests\nmvn test\n</code></pre>"},{"location":"getting-started/quick-setup/#module-specific-testing","title":"Module-Specific Testing","text":"<pre><code># Test specific authentication modules\nmvn test -pl jdbc-auth\nmvn test -pl ldap-auth\nmvn test -pl oauth2-auth\n</code></pre>"},{"location":"getting-started/quick-setup/#http-testing","title":"HTTP Testing","text":"<p>Use the provided <code>api-testing.http</code> file with your IDE's HTTP client:</p> <ol> <li>IntelliJ IDEA: Open <code>api-testing.http</code> \u2192 Click play buttons</li> <li>VS Code: Install REST Client extension \u2192 Open file \u2192 Send requests</li> <li>Postman: Import the collection (export available)</li> </ol>"},{"location":"getting-started/quick-setup/#docker-setup-optional","title":"\ud83d\udc33 Docker Setup (Optional)","text":"<p>For containerized development:</p>"},{"location":"getting-started/quick-setup/#build-docker-image","title":"Build Docker Image","text":"<pre><code># Build application image\ndocker build -t spring-security-ref .\n</code></pre>"},{"location":"getting-started/quick-setup/#run-with-docker-compose","title":"Run with Docker Compose","text":"<pre><code># Start all services\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f\n</code></pre>"},{"location":"getting-started/quick-setup/#services-available","title":"Services Available","text":"<ul> <li>Application: <code>http://localhost:8080</code></li> <li>Database: <code>localhost:5432</code> (PostgreSQL)</li> <li>LDAP: <code>localhost:8389</code> (Embedded)</li> </ul>"},{"location":"getting-started/quick-setup/#application-profiles","title":"\ud83d\udcca Application Profiles","text":"<p>The application supports multiple profiles for different scenarios:</p> Profile Description Modules Active <code>default</code> All authentication methods All modules <code>jdbc-only</code> Database authentication only jdbc-auth, common-* <code>ldap-only</code> LDAP authentication only ldap-auth, common-* <code>oauth2-only</code> OAuth2 authentication only oauth2-auth, common-*"},{"location":"getting-started/quick-setup/#activate-specific-profile","title":"Activate Specific Profile","text":"<pre><code># JDBC authentication only\nmvn spring-boot:run -pl rest-api -Dspring-boot.run.profiles=jdbc-only\n\n# LDAP authentication only  \nmvn spring-boot:run -pl rest-api -Dspring-boot.run.profiles=ldap-only\n</code></pre>"},{"location":"getting-started/quick-setup/#troubleshooting","title":"\ud83d\udd0d Troubleshooting","text":""},{"location":"getting-started/quick-setup/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/quick-setup/#port-already-in-use","title":"Port Already in Use","text":"<pre><code># Find process using port 8080\nnetstat -ano | findstr :8080    # Windows\nlsof -i :8080                   # macOS/Linux\n\n# Kill the process or use different port\nmvn spring-boot:run -pl rest-api -Dspring-boot.run.arguments=--server.port=8081\n</code></pre>"},{"location":"getting-started/quick-setup/#java-version-issues","title":"Java Version Issues","text":"<pre><code># Set JAVA_HOME\nexport JAVA_HOME=/path/to/java17    # macOS/Linux\nset JAVA_HOME=C:\\path\\to\\java17     # Windows\n\n# Verify Maven uses correct Java\nmvn -version\n</code></pre>"},{"location":"getting-started/quick-setup/#build-failures","title":"Build Failures","text":"<pre><code># Clean and rebuild\nmvn clean compile\n\n# Skip tests if needed\nmvn clean install -DskipTests\n</code></pre>"},{"location":"getting-started/quick-setup/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: Browse the troubleshooting guide</li> <li>\ud83d\udd0d Logs: Check application logs for detailed error messages</li> <li>\ud83d\udcac Community: Ask questions in project discussions</li> </ul>"},{"location":"getting-started/quick-setup/#success","title":"\ud83c\udf89 Success!","text":"<p>You now have the Spring Security Reference Project running locally! </p>"},{"location":"getting-started/quick-setup/#whats-next","title":"What's Next?","text":"<ul> <li>Project Structure \u2192 Explore the codebase organization</li> <li>Authentication Methods \u2192 Learn about different auth strategies</li> <li>API Testing \u2192 Try out the endpoints</li> </ul>"},{"location":"getting-started/quick-setup/#pro-tips","title":"\ud83d\udca1 Pro Tips","text":"<ul> <li>Use HTTP files: The <code>api-testing.http</code> file contains all example requests</li> <li>Check logs: Educational logging explains every security operation</li> <li>Try different profiles: Each profile demonstrates specific authentication methods</li> <li>Explore modules: Each authentication method is in its own independent module</li> </ul>"},{"location":"modules/graphql-service/","title":"GraphQL Service (Scaffold)","text":"<p>This module is a placeholder for future GraphQL API integration. It demonstrates how to extend the reference architecture to support GraphQL endpoints and security patterns.</p>"},{"location":"modules/graphql-service/#structure","title":"Structure","text":"<ul> <li><code>GraphQLController.java</code>: Example GraphQL query endpoint</li> <li><code>GraphQLSecurityInterceptor.java</code>: Placeholder for GraphQL security logic</li> </ul>"},{"location":"modules/graphql-service/#next-steps","title":"Next Steps","text":"<ul> <li>Add Spring GraphQL dependencies to your build</li> <li>Implement authentication and authorization for GraphQL queries and mutations</li> <li>Integrate with existing security modules (JWT, roles, etc.)</li> </ul> <p>This scaffold makes it easy to add GraphQL support as you continue learning.</p>"},{"location":"reference/advanced-patterns/","title":"Advanced Patterns (Reference)","text":""},{"location":"reference/advanced-patterns/#api-testing-example","title":"API Testing Example","text":"<p>This is a placeholder for advanced security patterns reference documentation.</p> <p>This is a placeholder for API testing documentation and examples.</p>"},{"location":"reference/custom-providers/","title":"Custom Providers (Reference)","text":"<p>This is a placeholder for custom authentication providers reference documentation.</p>"},{"location":"reference/diagrams/","title":"Project Architecture and Flow Diagrams","text":"<p>This page provides a detailed visual reference for the architecture, authentication flows, and security mechanisms used in the Spring Security Reference Project.</p>"},{"location":"reference/diagrams/#1-overall-project-architecture","title":"1. Overall Project Architecture","text":"<p>This diagram illustrates the modular architecture of the project, showing how different services and components are interconnected. The <code>rest-api</code> module is the central entry point, consuming functionality from various authentication and security modules.</p> <pre><code>graph TD\n    subgraph \"Entry Points\"\n        A[rest-api]\n    end\n\n    subgraph \"Core Security Modules\"\n        B[common-security]\n        C[common-auth]\n    end\n\n    subgraph \"Authentication Providers\"\n        D[jdbc-auth]\n        E[ldap-auth]\n        F[oauth2-auth]\n    end\n\n    subgraph \"Authorization\"\n        G[authorization-service]\n    end\n\n    subgraph \"External Systems\"\n        H[(Database)]\n        I[LDAP Directory]\n        J[OAuth2 Providers]\n    end\n\n    A --&gt; B\n    A --&gt; C\n    A --&gt; D\n    A --&gt; E\n    A --&gt; F\n    A --&gt; G\n\n    B --&gt; C\n    D --&gt; H\n    E --&gt; I\n    F --&gt; J\n\n    style A fill:#D5E8D4,stroke:#82B366\n    style B fill:#F8CECC,stroke:#B85450\n    style C fill:#F8CECC,stroke:#B85450\n    style D fill:#DAE8FC,stroke:#6C8EBF\n    style E fill:#DAE8FC,stroke:#6C8EBF\n    style F fill:#DAE8FC,stroke:#6C8EBF\n    style G fill:#E1D5E7,stroke:#9673A6</code></pre>"},{"location":"reference/diagrams/#key-takeaways","title":"Key Takeaways:","text":"<ul> <li>Modular Design: Each authentication method (<code>jdbc-auth</code>, <code>ldap-auth</code>, <code>oauth2-auth</code>) is a separate module.</li> <li>Shared Logic: <code>common-auth</code> and <code>common-security</code> provide reusable security configurations and utilities.</li> <li>Centralized API: The <code>rest-api</code> module integrates all security features and exposes the endpoints.</li> </ul>"},{"location":"reference/diagrams/#2-authentication-flow-session-based-login","title":"2. Authentication Flow - Session-Based Login","text":"<p>This sequence diagram shows the step-by-step process for a traditional, session-based user login.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Browser\n    participant SpringSecurity as Security Filter Chain\n    participant CustomAuthProvider as CustomAuthenticationProvider\n    participant AuthService as AuthService\n    participant SessionRegistry\n\n    User-&gt;&gt;Browser: Submits username &amp; password\n    Browser-&gt;&gt;SpringSecurity: POST /login\n    SpringSecurity-&gt;&gt;CustomAuthProvider: authenticate(Authentication)\n    CustomAuthProvider-&gt;&gt;AuthService: authenticateSession(username, password)\n    AuthService--&gt;&gt;CustomAuthProvider: UserDetails (or throws Exception)\n    CustomAuthProvider--&gt;&gt;SpringSecurity: return new UsernamePasswordAuthenticationToken\n    SpringSecurity-&gt;&gt;SessionRegistry: Creates new Session\n    SpringSecurity-&gt;&gt;Browser: Redirect to home, Set JSESSIONID Cookie\n    Browser-&gt;&gt;User: Displays logged-in page</code></pre>"},{"location":"reference/diagrams/#flow-explanation","title":"Flow Explanation:","text":"<ol> <li>The user submits their credentials via a login form.</li> <li>Spring Security's filter chain intercepts the request.</li> <li>The <code>CustomAuthenticationProvider</code> is invoked.</li> <li>It delegates the core authentication logic to the <code>AuthService</code>.</li> <li>If successful, an <code>Authentication</code> object is returned and stored in the <code>SecurityContext</code>.</li> <li>A <code>JSESSIONID</code> cookie is created, and the user is logged in.</li> </ol>"},{"location":"reference/diagrams/#3-authentication-flow-jwt-based-login","title":"3. Authentication Flow - JWT-Based Login","text":"<p>This diagram details the process of obtaining and using a JSON Web Token (JWT) for stateless authentication.</p> <pre><code>sequenceDiagram\n    participant User\n    participant ClientApp as Client Application\n    participant ApiService as /api/auth/login\n    participant JwtTokenUtil\n    participant SecuredEndpoint as /api/admin/*\n    participant JwtAuthFilter as JwtAuthenticationFilter\n\n    User-&gt;&gt;ClientApp: Enters credentials\n    ClientApp-&gt;&gt;ApiService: POST with username &amp; password\n    ApiService-&gt;&gt;JwtTokenUtil: generateToken(userDetails)\n    JwtTokenUtil--&gt;&gt;ApiService: Returns JWT (Access Token)\n    ApiService--&gt;&gt;ClientApp: Sends JWT to client\n    ClientApp-&gt;&gt;User: Stores JWT securely (e.g., memory)\n\n    User-&gt;&gt;ClientApp: Clicks on a secured action\n    ClientApp-&gt;&gt;SecuredEndpoint: Request with \"Authorization: Bearer &lt;JWT&gt;\" header\n    SecuredEndpoint-&gt;&gt;JwtAuthFilter: Intercepts request\n    JwtAuthFilter-&gt;&gt;JwtTokenUtil: validateToken(JWT)\n    JwtTokenUtil--&gt;&gt;JwtAuthFilter: Returns Claims (username, roles)\n    JwtAuthFilter-&gt;&gt;SpringSecurity: Sets SecurityContextHolder\n    SecuredEndpoint--&gt;&gt;ClientApp: Returns secured resource</code></pre>"},{"location":"reference/diagrams/#flow-explanation_1","title":"Flow Explanation:","text":"<ol> <li>The user logs in at a dedicated endpoint (<code>/api/auth/login</code>).</li> <li>The server validates credentials and uses <code>JwtTokenUtil</code> to generate a token.</li> <li>The token is sent back to the client.</li> <li>For subsequent requests to secured endpoints, the client sends the JWT in the <code>Authorization</code> header.</li> <li>The <code>JwtAuthenticationFilter</code> intercepts the request, validates the token, and sets the security context, allowing access.</li> </ol>"},{"location":"reference/diagrams/#4-spring-security-filter-chain","title":"4. Spring Security Filter Chain","text":"<p>This diagram visualizes the key filters in the Spring Security chain and their order of execution.</p> <pre><code>graph LR\n    subgraph \"Flow\"\n        Req(Request) --&gt; F1[CsrfFilter]\n        F1 --&gt; F2[HeaderWriterFilter]\n        F2 --&gt; F3[JwtAuthenticationFilter]\n        F3 --&gt; F4[UsernamePasswordAuthenticationFilter]\n        F4 --&gt; F5[AuthorizationFilter]\n        F5 --&gt; Controller(Controller Endpoint)\n    end\n\n    style F1 fill:#F8CECC,stroke:#B85450\n    style F2 fill:#F8CECC,stroke:#B85450\n    style F3 fill:#DAE8FC,stroke:#6C8EBF\n    style F4 fill:#DAE8FC,stroke:#6C8EBF\n    style F5 fill:#D5E8D4,stroke:#82B366</code></pre>"},{"location":"reference/diagrams/#filter-descriptions","title":"Filter Descriptions:","text":"<ul> <li><code>CsrfFilter</code>: Protects against Cross-Site Request Forgery attacks.</li> <li><code>HeaderWriterFilter</code>: Adds security-related headers to the response (e.g., <code>X-Content-Type-Options</code>).</li> <li><code>JwtAuthenticationFilter</code>: (Custom) Validates JWTs from the <code>Authorization</code> header.</li> <li><code>UsernamePasswordAuthenticationFilter</code>: Handles form-based login submissions.</li> <li><code>AuthorizationFilter</code>: Enforces access control rules on endpoints based on user roles/permissions.</li> </ul>"},{"location":"reference/diagrams/#5-authorization-logic","title":"5. Authorization Logic","text":"<p>This flowchart explains how the system determines if a user has permission to access a secured resource.</p> <pre><code>flowchart TD;\n  A[User requests secured endpoint] --&gt; B{Is user authenticated?};\n  B -- No --&gt; C[Access Denied (401 Unauthorized)];\n  B -- Yes --&gt; D{Endpoint requires role?};\n  D -- No --&gt; E[Access Granted];\n  D -- Yes --&gt; F{User has required role?};\n  F -- No --&gt; G[Access Denied (403 Forbidden)];\n  F -- Yes --&gt; H{Endpoint requires permission?};\n  H -- No --&gt; E;\n  H -- Yes --&gt; I{Role includes permission?};\n  I -- No --&gt; G;\n  I -- Yes --&gt; E;</code></pre>"},{"location":"reference/diagrams/#logic-explanation","title":"Logic Explanation:","text":"<ol> <li>The system first checks if the user is authenticated at all.</li> <li>It then checks if the requested endpoint is protected by a specific role (e.g., <code>ROLE_ADMIN</code>).</li> <li>If a role is required, it verifies the user has that role.</li> <li>Finally, for more granular control, it can check for specific permissions associated with the user's role (e.g., <code>CAN_DELETE_USER</code>).</li> <li>Access is only granted if all checks pass.</li> </ol>"},{"location":"reference/diagrams/#6-grpc-and-websocket-security-interception","title":"6. gRPC and WebSocket Security Interception","text":"<p>These diagrams show how security is applied to non-HTTP protocols like gRPC and WebSockets using interceptors.</p>"},{"location":"reference/diagrams/#grpc-security-interceptor","title":"gRPC Security Interceptor","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant GrpcServer as gRPC Server\n    participant GrpcSecurityInterceptor as Security Interceptor\n    participant JwtTokenUtil\n    participant ServiceImpl as gRPC Service Implementation\n\n    Client-&gt;&gt;GrpcServer: gRPC call with JWT in Metadata\n    GrpcServer-&gt;&gt;GrpcSecurityInterceptor: interceptCall(call, headers)\n    GrpcSecurityInterceptor-&gt;&gt;JwtTokenUtil: Validate JWT from headers\n    alt Invalid Token\n        GrpcSecurityInterceptor--&gt;&gt;Client: close(Status.UNAUTHENTICATED)\n    else Valid Token\n        GrpcSecurityInterceptor-&gt;&gt;ServiceImpl: forward(call, headers)\n        ServiceImpl--&gt;&gt;GrpcSecurityInterceptor: Response\n        GrpcSecurityInterceptor--&gt;&gt;Client: Response\n    end</code></pre>"},{"location":"reference/diagrams/#websocket-security-interceptor","title":"WebSocket Security Interceptor","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant WebSocketBroker\n    participant WebSocketSecurityInterceptor as Security Interceptor\n    participant JwtTokenUtil\n\n    Client-&gt;&gt;WebSocketBroker: CONNECT frame with JWT\n    WebSocketBroker-&gt;&gt;WebSocketSecurityInterceptor: preSend(message, channel)\n    WebSocketSecurityInterceptor-&gt;&gt;JwtTokenUtil: Validate JWT from message headers\n    alt Invalid Token\n        WebSocketSecurityInterceptor--&gt;&gt;Client: Throw AuthenticationException\n    else Valid Token\n        WebSocketSecurityInterceptor-&gt;&gt;WebSocketBroker: Allow message processing\n    end</code></pre>"},{"location":"reference/diagrams/#interceptor-explanation","title":"Interceptor Explanation:","text":"<ul> <li>gRPC: An interceptor extracts the JWT from the call's <code>Metadata</code> (headers), validates it, and either closes the call with an <code>UNAUTHENTICATED</code> status or forwards it to the service implementation.</li> <li>WebSocket: A <code>ChannelInterceptor</code> inspects messages on the channel. The <code>preSend</code> method is used to validate a JWT sent during the <code>CONNECT</code> phase, preventing unauthorized clients from subscribing or sending messages.</li> </ul>"},{"location":"reference/modules/","title":"Module Documentation","text":"<p>This is a placeholder for module documentation.</p>"},{"location":"reference/testing-auth/","title":"Testing Authentication (Reference)","text":"<p>This is a placeholder for authentication testing reference documentation.</p>"},{"location":"reference/troubleshooting/","title":"Troubleshooting","text":"<p>This is a placeholder for troubleshooting documentation.</p>"},{"location":"reference/troubleshooting/#examples-overview","title":"Examples Overview","text":"<p>This section provides practical examples and advanced patterns for Spring Security.</p> <ul> <li>Testing Authentication</li> <li>Custom Providers</li> <li>Advanced Patterns</li> </ul>"},{"location":"security/","title":"Security Configuration","text":"<p>This section covers the comprehensive security configuration patterns implemented in the Spring Security Reference project.</p>"},{"location":"security/#security-architecture-overview","title":"\ud83c\udfd7\ufe0f Security Architecture Overview","text":"<p>Our security configuration follows a layered, multi-provider architecture designed to demonstrate enterprise-grade Spring Security patterns:</p> <pre><code>graph TD\n    A[HTTP Request] --&gt; B[Security Filter Chain]\n    B --&gt; C{Authentication Required?}\n    C --&gt;|Yes| D[JWT Filter]\n    D --&gt; E[Multi-Auth Providers]\n    E --&gt; F[JDBC Provider]\n    E --&gt; G[LDAP Provider] \n    E --&gt; H[OAuth2 Provider]\n    E --&gt; I[Custom Provider]\n    F --&gt; J[Authorization Check]\n    G --&gt; J\n    H --&gt; J\n    I --&gt; J\n    J --&gt; K{Authorized?}\n    K --&gt;|Yes| L[Controller]\n    K --&gt;|No| M[403 Forbidden]\n    C --&gt;|No| L</code></pre>"},{"location":"security/#configuration-modules","title":"\ud83d\udd27 Configuration Modules","text":"Module Purpose Key Components common-security Core security configuration <code>MultiAuthSecurityConfig</code>, interceptors common-auth Authentication utilities JWT filters, custom providers authorization-service Role &amp; permission logic Authorization service, role management"},{"location":"security/#security-configuration-topics","title":"\ud83d\udccb Security Configuration Topics","text":""},{"location":"security/#common-security-configuration","title":"\ud83d\udee1\ufe0f Common Security Configuration","text":"<ul> <li>Multi-provider authentication setup</li> <li>Profile-based security configurations</li> <li>Cross-cutting security concerns</li> </ul>"},{"location":"security/#security-filter-chain","title":"\u26d3\ufe0f Security Filter Chain","text":"<ul> <li>Filter ordering and execution</li> <li>Custom filter integration</li> <li>JWT authentication flow</li> </ul>"},{"location":"security/#authorization-access-control","title":"\ud83d\udd10 Authorization &amp; Access Control","text":"<ul> <li>Role-based access control (RBAC)</li> <li>Method-level security</li> <li>Custom authorization logic</li> </ul>"},{"location":"security/#key-security-features","title":"\ud83c\udfaf Key Security Features","text":""},{"location":"security/#multi-authentication-support","title":"Multi-Authentication Support","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class MultiAuthSecurityConfig {\n\n    @Bean\n    public SecurityFilterChain defaultFilterChain(HttpSecurity http) {\n        return http\n            .authenticationProvider(customAuthenticationProvider)\n            .authenticationProvider(jdbcAuthenticationProvider)  \n            .authenticationProvider(ldapAuthenticationProvider)\n            .addFilterBefore(jwtAuthenticationFilter, \n                UsernamePasswordAuthenticationFilter.class)\n            .build();\n    }\n}\n</code></pre>"},{"location":"security/#profile-based-configuration","title":"Profile-Based Configuration","text":"<ul> <li>Default Profile: All authentication methods enabled</li> <li><code>jdbc-only</code>: Database authentication only</li> <li><code>ldap-only</code>: LDAP authentication only  </li> <li><code>oauth2-only</code>: Social login only</li> </ul>"},{"location":"security/#security-endpoints","title":"Security Endpoints","text":"<pre><code>Authorization Rules:\n  Public Access:\n    - /api/public/**     # No authentication required\n    - /api/auth/**       # Login endpoints\n    - /actuator/health   # Health checks\n\n  Role-Based Access:\n    - /api/admin/**      # ROLE_ADMIN required\n    - /api/user/**       # ROLE_USER or ROLE_ADMIN\n    - /api/jdbc/**       # Database auth endpoints\n    - /api/ldap/**       # LDAP auth endpoints\n</code></pre>"},{"location":"security/#security-best-practices-demonstrated","title":"\ud83d\udd12 Security Best Practices Demonstrated","text":""},{"location":"security/#authentication","title":"\u2705 Authentication","text":"<ul> <li>JWT Token Security: Stateless authentication with secure token validation</li> <li>Password Encoding: BCrypt hashing for database credentials</li> <li>Session Management: Configurable session policies per profile</li> <li>CSRF Protection: Disabled for APIs, configurable for web forms</li> </ul>"},{"location":"security/#authorization","title":"\u2705 Authorization","text":"<ul> <li>Role Hierarchy: Admin inherits user permissions</li> <li>Method Security: <code>@PreAuthorize</code> and <code>@Secured</code> annotations</li> <li>Path-Based Security: URL pattern matching for access control</li> <li>Custom Authorization: Business logic-based authorization rules</li> </ul>"},{"location":"security/#security-headers","title":"\u2705 Security Headers","text":"<ul> <li>CORS Configuration: Cross-origin request handling</li> <li>Content Security Policy: XSS protection headers</li> <li>Secure Headers: X-Frame-Options, X-Content-Type-Options</li> </ul>"},{"location":"security/#learning-objectives","title":"\ud83c\udf93 Learning Objectives","text":"<p>By studying this security configuration, you'll learn:</p> <ol> <li>Multi-Provider Setup - How to configure multiple authentication methods</li> <li>Filter Chain Design - Proper ordering and custom filter integration  </li> <li>Profile-Based Config - Environment-specific security configurations</li> <li>Authorization Patterns - Role-based and method-level security</li> <li>Security Testing - How to test different authentication flows</li> </ol>"},{"location":"security/#quick-navigation","title":"\ud83d\ude80 Quick Navigation","text":"<ul> <li>Common Security \u2192 - Core security configuration patterns</li> <li>Filter Chain \u2192 - Security filter implementation details  </li> <li>Authorization \u2192 - Access control and role management</li> <li>Authentication \u2192 - Authentication method details</li> <li>API Reference \u2192 - Secured endpoint documentation</li> </ul> <p>\ud83c\udfaf Start with Common Security Configuration to understand the foundation of our security setup.</p>"},{"location":"security/authorization/","title":"Authorization &amp; Access Control","text":"<p>Authorization is the process of determining what an authenticated user is allowed to do. This guide covers the comprehensive authorization patterns implemented in our Spring Security reference project.</p>"},{"location":"security/authorization/#authorization-architecture","title":"\ud83c\udfaf Authorization Architecture","text":""},{"location":"security/authorization/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<pre><code>graph TD\n    A[Authenticated User] --&gt; B{Role Check}\n    B --&gt;|ROLE_ADMIN| C[Admin Access]\n    B --&gt;|ROLE_USER| D[User Access]  \n    B --&gt;|No Role| E[Access Denied]\n\n    C --&gt; F[/api/admin/**]\n    C --&gt; G[/api/user/**]\n    C --&gt; H[All Endpoints]\n\n    D --&gt; I[/api/user/**]\n    D --&gt; J[Public Endpoints]\n\n    E --&gt; K[403 Forbidden]</code></pre>"},{"location":"security/authorization/#authorization-layers","title":"Authorization Layers","text":"Layer Implementation Purpose URL-Based <code>authorizeHttpRequests()</code> Path-level access control Method-Based <code>@PreAuthorize</code>, <code>@Secured</code> Fine-grained method security Business Logic <code>AuthorizationService</code> Custom authorization rules"},{"location":"security/authorization/#url-based-authorization","title":"\ud83d\udee1\ufe0f URL-Based Authorization","text":""},{"location":"security/authorization/#authorization-rules-configuration","title":"Authorization Rules Configuration","text":"<pre><code>@Bean\npublic SecurityFilterChain defaultFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .authorizeHttpRequests(authz -&gt; authz\n            // Public endpoints - no authentication required\n            .requestMatchers(\"/api/public/**\", \"/api/auth/**\").permitAll()\n            .requestMatchers(\"/actuator/health\").permitAll()\n\n            // OAuth2 endpoints  \n            .requestMatchers(\"/oauth2/**\", \"/login/oauth2/**\").permitAll()\n\n            // Admin-only endpoints\n            .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n\n            // User endpoints - both USER and ADMIN roles allowed\n            .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n\n            // Authentication method specific endpoints\n            .requestMatchers(\"/api/jdbc/**\").hasAnyRole(\"USER\", \"ADMIN\")\n            .requestMatchers(\"/api/ldap/**\").hasAnyRole(\"USER\", \"ADMIN\")\n\n            // Everything else requires authentication\n            .anyRequest().authenticated()\n        )\n        .build();\n}\n</code></pre>"},{"location":"security/authorization/#authorization-rule-evaluation","title":"Authorization Rule Evaluation","text":"<pre><code>sequenceDiagram\n    participant R as Request\n    participant AF as AuthorizationFilter\n    participant AM as AuthorizationManager\n    participant AS as AuthorizationService\n    participant C as Controller\n\n    R-&gt;&gt;AF: HTTP Request to /api/admin/users\n    AF-&gt;&gt;AM: Check authorization for path\n    AM-&gt;&gt;AM: Evaluate: hasRole(\"ADMIN\")\n    AM-&gt;&gt;AS: Get user authorities\n    AS-&gt;&gt;AM: Return [ROLE_ADMIN, ROLE_USER]\n    AM-&gt;&gt;AF: Authorization granted\n    AF-&gt;&gt;C: Forward request\n    C-&gt;&gt;R: Response</code></pre>"},{"location":"security/authorization/#method-level-authorization","title":"\ud83d\udd10 Method-Level Authorization","text":""},{"location":"security/authorization/#preauthorize-examples","title":"@PreAuthorize Examples","text":"<pre><code>@RestController\npublic class AdminController {\n\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    @GetMapping(\"/api/admin/users\")\n    public List&lt;User&gt; getAllUsers() {\n        return userService.findAll();\n    }\n\n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.name\")\n    @GetMapping(\"/api/admin/users/{userId}\")\n    public User getUser(@PathVariable String userId) {\n        // Admin can access any user, regular users only themselves\n        return userService.findById(userId);\n    }\n\n    @PreAuthorize(\"hasAuthority('USER_WRITE') and hasRole('ADMIN')\")\n    @PostMapping(\"/api/admin/users\")\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n}\n</code></pre>"},{"location":"security/authorization/#secured-examples","title":"@Secured Examples","text":"<pre><code>@RestController\npublic class UserController {\n\n    @Secured(\"ROLE_USER\")\n    @GetMapping(\"/api/user/profile\")\n    public UserProfile getProfile(Authentication auth) {\n        return userService.getProfile(auth.getName());\n    }\n\n    @Secured({\"ROLE_USER\", \"ROLE_ADMIN\"})  \n    @PutMapping(\"/api/user/profile\")\n    public UserProfile updateProfile(@RequestBody UserProfile profile) {\n        return userService.updateProfile(profile);\n    }\n}\n</code></pre>"},{"location":"security/authorization/#method-security-configuration","title":"Method Security Configuration","text":"<pre><code>@Configuration\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true,    // Enable @PreAuthorize/@PostAuthorize\n    securedEnabled = true,    // Enable @Secured\n    jsr250Enabled = true      // Enable @RolesAllowed\n)\npublic class MethodSecurityConfig {\n    // Method-level security enabled\n}\n</code></pre>"},{"location":"security/authorization/#custom-authorization-service","title":"\ud83c\udfaf Custom Authorization Service","text":""},{"location":"security/authorization/#authorizationservice-implementation","title":"AuthorizationService Implementation","text":"<pre><code>@Service\npublic class AuthorizationService {\n\n    private final UserRepository userRepository;\n    private final RoleRepository roleRepository;\n\n    /**\n     * Get user's role from database\n     */\n    public String getUserRole(String username) {\n        return userRepository.findByUsername(username)\n            .map(User::getRole)\n            .orElse(\"ROLE_USER\");\n    }\n\n    /**\n     * Check if user has specific permission\n     */\n    public boolean hasPermission(String username, String permission) {\n        User user = userRepository.findByUsername(username).orElse(null);\n        if (user == null) return false;\n\n        return user.getPermissions().contains(permission);\n    }\n\n    /**\n     * Get all user authorities (roles + permissions)\n     */\n    public Set&lt;String&gt; getUserAuthorities(String username) {\n        User user = userRepository.findByUsername(username).orElse(null);\n        if (user == null) return Set.of();\n\n        Set&lt;String&gt; authorities = new HashSet&lt;&gt;();\n        authorities.add(user.getRole());\n        authorities.addAll(user.getPermissions());\n        return authorities;\n    }\n\n    /**\n     * Business logic authorization\n     */\n    public boolean canAccessResource(String username, String resourceId, String action) {\n        // Custom business logic\n        User user = userRepository.findByUsername(username).orElse(null);\n        if (user == null) return false;\n\n        // Admin can access everything\n        if (\"ROLE_ADMIN\".equals(user.getRole())) {\n            return true;\n        }\n\n        // Resource owner can access their own resources\n        Resource resource = resourceRepository.findById(resourceId).orElse(null);\n        if (resource != null &amp;&amp; username.equals(resource.getOwnerId())) {\n            return true;\n        }\n\n        // Check specific permissions\n        String requiredPermission = resourceId + \":\" + action;\n        return user.getPermissions().contains(requiredPermission);\n    }\n}\n</code></pre>"},{"location":"security/authorization/#using-authorizationservice-in-controllers","title":"Using AuthorizationService in Controllers","text":"<pre><code>@RestController\npublic class ResourceController {\n\n    @Autowired\n    private AuthorizationService authorizationService;\n\n    @GetMapping(\"/api/resources/{resourceId}\")\n    public ResponseEntity&lt;Resource&gt; getResource(\n            @PathVariable String resourceId,\n            Authentication auth) {\n\n        // Custom authorization check\n        if (!authorizationService.canAccessResource(auth.getName(), resourceId, \"READ\")) {\n            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();\n        }\n\n        Resource resource = resourceService.findById(resourceId);\n        return ResponseEntity.ok(resource);\n    }\n}\n</code></pre>"},{"location":"security/authorization/#role-hierarchy","title":"\ud83d\udd04 Role Hierarchy","text":""},{"location":"security/authorization/#role-hierarchy-configuration","title":"Role Hierarchy Configuration","text":"<pre><code>@Bean\npublic RoleHierarchy roleHierarchy() {\n    RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();\n    roleHierarchy.setHierarchy(\"ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_GUEST\");\n    return roleHierarchy;\n}\n\n@Bean  \npublic DefaultWebSecurityExpressionHandler expressionHandler() {\n    DefaultWebSecurityExpressionHandler expressionHandler = \n        new DefaultWebSecurityExpressionHandler();\n    expressionHandler.setRoleHierarchy(roleHierarchy());\n    return expressionHandler;\n}\n</code></pre>"},{"location":"security/authorization/#role-hierarchy-benefits","title":"Role Hierarchy Benefits","text":"<pre><code>// With hierarchy: ROLE_ADMIN &gt; ROLE_USER\n@PreAuthorize(\"hasRole('USER')\")  // ADMIN users also have access\npublic String userEndpoint() {\n    return \"User content\";\n}\n\n// Without hierarchy\n@PreAuthorize(\"hasRole('USER') or hasRole('ADMIN')\")  // Must be explicit\npublic String userEndpoint() {  \n    return \"User content\";\n}\n</code></pre>"},{"location":"security/authorization/#authorization-by-authentication-method","title":"\ud83c\udfad Authorization by Authentication Method","text":""},{"location":"security/authorization/#jwt-token-authorization","title":"JWT Token Authorization","text":"<pre><code>public class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws ServletException, IOException {\n        // Extract JWT and validate\n        if (jwtToken != null) {\n            Claims claims = jwtTokenUtil.getClaimsFromToken(jwtToken);\n            String username = claims.getSubject();\n            String role = claims.get(\"role\", String.class);\n\n            // Create authorities from JWT claims\n            List&lt;SimpleGrantedAuthority&gt; authorities = List.of(\n                new SimpleGrantedAuthority(role)\n            );\n\n            // Set authentication with authorities\n            UsernamePasswordAuthenticationToken authToken =\n                    new UsernamePasswordAuthenticationToken(username, null, authorities);\n            SecurityContextHolder.getContext().setAuthentication(authToken);\n        }\n\n        chain.doFilter(request, response);\n    }\n}\n</code></pre>"},{"location":"security/authorization/#database-authorization","title":"Database Authorization","text":"<pre><code>@Configuration\npublic class JdbcAuthConfig {\n\n    @Bean\n    public UserDetailsService userDetailsService() {\n        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);\n\n        // Custom queries to load user authorities\n        manager.setUsersByUsernameQuery(\n            \"SELECT username, password, enabled FROM users WHERE username = ?\");\n        manager.setAuthoritiesByUsernameQuery(\n            \"SELECT username, authority FROM authorities WHERE username = ?\");\n\n        return manager;\n    }\n}\n</code></pre>"},{"location":"security/authorization/#ldap-authorization","title":"LDAP Authorization","text":"<pre><code>@Configuration  \npublic class LdapAuthConfig {\n\n    @Bean\n    public LdapAuthoritiesPopulator ldapAuthoritiesPopulator() {\n        DefaultLdapAuthoritiesPopulator populator = \n            new DefaultLdapAuthoritiesPopulator(ldapContextSource(), \"ou=groups\");\n\n        // Map LDAP groups to Spring Security authorities\n        populator.setGroupRoleAttribute(\"cn\");\n        populator.setGroupSearchFilter(\"member={0}\");\n        populator.setRolePrefix(\"ROLE_\");\n        populator.setConvertToUpperCase(true);\n\n        return populator;\n    }\n}\n</code></pre>"},{"location":"security/authorization/#access-denied-handling","title":"\ud83d\udeab Access Denied Handling","text":""},{"location":"security/authorization/#custom-access-denied-handler","title":"Custom Access Denied Handler","text":"<pre><code>@Component\npublic class CustomAccessDeniedHandler implements AccessDeniedHandler {\n\n    @Override\n    public void handle(HttpServletRequest request,\n                       HttpServletResponse response,\n                       AccessDeniedException accessDeniedException) throws IOException {\n\n        // Log security violation\n        logger.warn(\"Access denied for user {} to {}\", \n            request.getRemoteUser(), request.getRequestURI());\n\n        // Return JSON error response for API calls\n        if (request.getRequestURI().startsWith(\"/api/\")) {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            response.setContentType(\"application/json\");\n\n            String jsonResponse = \"\"\"\n                {\n                    \"error\": \"Access Denied\",\n                    \"message\": \"You don't have permission to access this resource\",\n                    \"timestamp\": \"%s\",\n                    \"path\": \"%s\"\n                }\n                \"\"\".formatted(Instant.now().toString(), request.getRequestURI());\n\n            response.getWriter().write(jsonResponse);\n        } else {\n            // Redirect to access denied page for web requests\n            response.sendRedirect(\"/access-denied\");\n        }\n    }\n}\n</code></pre>"},{"location":"security/authorization/#configure-access-denied-handler","title":"Configure Access Denied Handler","text":"<pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    return http\n        .exceptionHandling(ex -&gt; ex\n            .accessDeniedHandler(customAccessDeniedHandler)\n        )\n        .build();\n}\n</code></pre>"},{"location":"security/authorization/#authorization-testing","title":"\ud83d\udcca Authorization Testing","text":""},{"location":"security/authorization/#testing-role-based-access","title":"Testing Role-Based Access","text":"<pre><code>@Test\n@WithMockUser(roles = \"ADMIN\")\nvoid adminCanAccessAdminEndpoints() throws Exception {\n    mockMvc.perform(get(\"/api/admin/users\"))\n        .andExpect(status().isOk());\n}\n\n@Test\n@WithMockUser(roles = \"USER\")  \nvoid userCannotAccessAdminEndpoints() throws Exception {\n    mockMvc.perform(get(\"/api/admin/users\"))\n        .andExpect(status().isForbidden());\n}\n\n@Test\n@WithMockUser(username = \"john\", roles = \"USER\")\nvoid userCanAccessOwnProfile() throws Exception {\n    mockMvc.perform(get(\"/api/user/profile\"))\n        .andExpect(status().isOk());\n}\n</code></pre>"},{"location":"security/authorization/#testing-method-security","title":"Testing Method Security","text":"<pre><code>@Test\nvoid testMethodSecurityWithPreAuthorize() {\n    // Arrange\n    SecurityContextHolder.getContext().setAuthentication(\n        new TestingAuthenticationToken(\"admin\", null, \"ROLE_ADMIN\"));\n\n    // Act &amp; Assert\n    assertDoesNotThrow(() -&gt; adminService.deleteUser(\"user123\"));\n}\n\n@Test  \nvoid testMethodSecurityAccessDenied() {\n    // Arrange\n    SecurityContextHolder.getContext().setAuthentication(\n        new TestingAuthenticationToken(\"user\", null, \"ROLE_USER\"));\n\n    // Act &amp; Assert\n    assertThrows(AccessDeniedException.class, \n        () -&gt; adminService.deleteUser(\"user123\"));\n}\n</code></pre>"},{"location":"security/authorization/#authorization-best-practices","title":"\ud83c\udf93 Authorization Best Practices","text":""},{"location":"security/authorization/#dos","title":"\u2705 Do's","text":"<ol> <li>Use role hierarchy for cleaner authorization rules</li> <li>Implement business logic authorization for complex scenarios  </li> <li>Test authorization thoroughly with different user roles</li> <li>Log access violations for security monitoring</li> <li>Use method-level security for fine-grained control</li> </ol>"},{"location":"security/authorization/#donts","title":"\u274c Don'ts","text":"<ol> <li>Don't hardcode roles in business logic - use configuration</li> <li>Don't bypass authorization in internal service calls  </li> <li>Don't expose sensitive data in error messages</li> <li>Don't rely only on frontend authorization - always secure the backend</li> <li>Don't forget to secure actuator endpoints in production</li> </ol>"},{"location":"security/authorization/#security-considerations","title":"\ud83d\udee1\ufe0f Security Considerations","text":"<ul> <li>Principle of Least Privilege: Users get minimum necessary permissions</li> <li>Defense in Depth: Multiple authorization layers (URL + method + business logic)</li> <li>Fail Secure: Default to denying access when in doubt</li> <li>Audit Trail: Log all authorization decisions for compliance</li> </ul>"},{"location":"security/authorization/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Authentication Methods \u2192 - How users get authenticated</li> <li>API Security \u2192 - Securing REST endpoints  </li> <li>Testing Authorization \u2192 - Authorization testing patterns</li> <li>Production Deployment \u2192 - Production security considerations</li> </ul> <p>\ud83c\udfaf Authorization determines what authenticated users can do. The combination of URL-based, method-level, and custom business logic authorization provides comprehensive access control for enterprise applications.</p>"},{"location":"security/common-security/","title":"Common Security Configuration","text":"<p>The <code>common-security</code> module provides the foundational security configuration for the entire project, implementing a sophisticated multi-provider authentication system.</p>"},{"location":"security/common-security/#module-overview","title":"\ud83c\udfd7\ufe0f Module Overview","text":"<pre><code>Module: common-security\nPurpose: Core security configuration and cross-cutting security concerns\nLocation: common-security/src/main/java/com/example/commonsecurity/\nKey Files:\n  - MultiAuthSecurityConfig.java    # Main security configuration\n  - SecurityConfig.java             # Basic security setup\n  - GrpcSecurityInterceptor.java    # gRPC security\n  - WebSocketSecurityInterceptor.java # WebSocket security\n</code></pre>"},{"location":"security/common-security/#multiauthsecurityconfig","title":"\ud83c\udfaf MultiAuthSecurityConfig","text":"<p>The heart of our security configuration, supporting multiple authentication methods through Spring profiles.</p>"},{"location":"security/common-security/#configuration-architecture","title":"Configuration Architecture","text":"<pre><code>graph LR\n    A[MultiAuthSecurityConfig] --&gt; B[Default Profile]\n    A --&gt; C[oauth2-only Profile]\n    A --&gt; D[jdbc-only Profile] \n    A --&gt; E[ldap-only Profile]\n\n    B --&gt; F[All Auth Methods]\n    C --&gt; G[OAuth2 Only]\n    D --&gt; H[Database Only]\n    E --&gt; I[LDAP Only]</code></pre>"},{"location":"security/common-security/#profile-based-security-chains","title":"Profile-Based Security Chains","text":"Default Profile (All Methods)OAuth2-Only ProfileJDBC-Only ProfileLDAP-Only Profile <pre><code>@Bean\n@Profile(\"!oauth2-only &amp; !jdbc-only &amp; !ldap-only\")\npublic SecurityFilterChain defaultFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .csrf(csrf -&gt; csrf.disable())\n        .sessionManagement(session -&gt; session.sessionCreationPolicy(STATELESS))\n        .authorizeHttpRequests(authz -&gt; authz\n            .requestMatchers(\"/api/public/**\", \"/api/auth/**\").permitAll()\n            .requestMatchers(\"/oauth2/**\", \"/login/oauth2/**\").permitAll()\n            .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n            .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n            .requestMatchers(\"/api/jdbc/**\").hasAnyRole(\"USER\", \"ADMIN\")\n            .requestMatchers(\"/api/ldap/**\").hasAnyRole(\"USER\", \"ADMIN\")\n            .requestMatchers(\"/actuator/health\").permitAll()\n            .anyRequest().authenticated()\n        )\n        .authenticationProvider(customAuthenticationProvider)\n        .authenticationProvider(jdbcAuthenticationProvider)\n        .authenticationProvider(ldapAuthenticationProvider)\n        .oauth2Login(oauth2 -&gt; {\n            oauth2.userInfoEndpoint(userInfo -&gt; userInfo.userService(oauth2UserService));\n            if (oauth2AuthenticationSuccessHandler != null) {\n                oauth2.successHandler(oauth2AuthenticationSuccessHandler);\n            }\n        })\n        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n        .build();\n}\n</code></pre> <pre><code>@Bean\n@Profile(\"oauth2-only\")\npublic SecurityFilterChain oauth2OnlyFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .csrf(csrf -&gt; csrf.disable())\n        .authorizeHttpRequests(authz -&gt; authz\n            .requestMatchers(\"/\", \"/login\", \"/oauth2/**\", \"/login/oauth2/**\").permitAll()\n            .anyRequest().authenticated()\n        )\n        .oauth2Login(oauth2 -&gt; {\n            if (oauth2UserService != null) {\n                oauth2.userInfoEndpoint(userInfo -&gt; userInfo.userService(oauth2UserService));\n            }\n            if (oauth2AuthenticationSuccessHandler != null) {\n                oauth2.successHandler(oauth2AuthenticationSuccessHandler);\n            }\n        })\n        .build();\n}\n</code></pre> <pre><code>@Bean\n@Profile(\"jdbc-only\")\npublic SecurityFilterChain jdbcOnlyFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .csrf(csrf -&gt; csrf.disable())\n        .sessionManagement(session -&gt; session.sessionCreationPolicy(IF_REQUIRED))\n        .authorizeHttpRequests(authz -&gt; authz\n            .requestMatchers(\"/api/public/**\", \"/login\", \"/logout\").permitAll()\n            .anyRequest().authenticated()\n        )\n        .formLogin(form -&gt; form\n            .loginPage(\"/login\")\n            .permitAll()\n        )\n        .logout(logout -&gt; logout.permitAll())\n        .authenticationProvider(jdbcAuthenticationProvider)\n        .build();\n}\n</code></pre> <pre><code>@Bean\n@Profile(\"ldap-only\")\npublic SecurityFilterChain ldapOnlyFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .csrf(csrf -&gt; csrf.disable())\n        .sessionManagement(session -&gt; session.sessionCreationPolicy(IF_REQUIRED))\n        .authorizeHttpRequests(authz -&gt; authz\n            .requestMatchers(\"/api/public/**\", \"/login\", \"/logout\").permitAll()\n            .anyRequest().authenticated()\n        )\n        .formLogin(form -&gt; form\n            .loginPage(\"/login\")\n            .permitAll()\n        )\n        .logout(logout -&gt; logout.permitAll())\n        .authenticationProvider(ldapAuthenticationProvider)\n        .build();\n}\n</code></pre>"},{"location":"security/common-security/#security-configuration-details","title":"\ud83d\udd27 Security Configuration Details","text":""},{"location":"security/common-security/#authentication-providers","title":"Authentication Providers","text":"Provider Purpose Auto-Configuration <code>CustomAuthenticationProvider</code> Session-based auth Always available <code>JdbcAuthenticationProvider</code> Database users Conditional (<code>@Autowired(required = false)</code>) <code>LdapAuthenticationProvider</code> Directory users Conditional (<code>@Autowired(required = false)</code>) <code>OAuth2UserService</code> Social login Conditional (<code>@Autowired(required = false)</code>)"},{"location":"security/common-security/#security-features","title":"Security Features","text":""},{"location":"security/common-security/#csrf-protection","title":"\ud83d\udee1\ufe0f CSRF Protection","text":"<pre><code>// Disabled for API-first design\n.csrf(csrf -&gt; csrf.disable())\n</code></pre>"},{"location":"security/common-security/#session-management","title":"\ud83d\udd10 Session Management","text":"<pre><code>// Stateless for default (JWT) profile\n.sessionManagement(session -&gt; session.sessionCreationPolicy(STATELESS))\n\n// Stateful for form-based profiles  \n.sessionManagement(session -&gt; session.sessionCreationPolicy(IF_REQUIRED))\n</code></pre>"},{"location":"security/common-security/#authorization-rules","title":"\ud83c\udfaf Authorization Rules","text":"<pre><code>.authorizeHttpRequests(authz -&gt; authz\n    // Public endpoints\n    .requestMatchers(\"/api/public/**\", \"/api/auth/**\").permitAll()\n    // OAuth2 endpoints\n    .requestMatchers(\"/oauth2/**\", \"/login/oauth2/**\").permitAll()\n    // Role-based endpoints\n    .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n    .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n    // Auth-method specific endpoints\n    .requestMatchers(\"/api/jdbc/**\").hasAnyRole(\"USER\", \"ADMIN\")\n    .requestMatchers(\"/api/ldap/**\").hasAnyRole(\"USER\", \"ADMIN\")\n    // Health check\n    .requestMatchers(\"/actuator/health\").permitAll()\n    // Everything else requires authentication\n    .anyRequest().authenticated()\n)\n</code></pre>"},{"location":"security/common-security/#multi-protocol-security","title":"\ud83c\udf10 Multi-Protocol Security","text":""},{"location":"security/common-security/#grpc-security-interceptor","title":"gRPC Security Interceptor","text":"<pre><code>@Bean\npublic GrpcSecurityInterceptor grpcSecurityInterceptor() {\n    return new GrpcSecurityInterceptor();\n}\n</code></pre> <p>Features: - JWT token validation for gRPC calls - Metadata-based authentication - Status code mapping for security errors</p>"},{"location":"security/common-security/#websocket-security-interceptor","title":"WebSocket Security Interceptor","text":"<pre><code>@Bean  \npublic WebSocketSecurityInterceptor webSocketSecurityInterceptor() {\n    return new WebSocketSecurityInterceptor();\n}\n</code></pre> <p>Features: - Channel-level message interception - Session-based WebSocket authentication - Real-time security validation</p>"},{"location":"security/common-security/#configuration-properties","title":"\ud83d\udccb Configuration Properties","text":""},{"location":"security/common-security/#profile-activation","title":"Profile Activation","text":"<pre><code># All authentication methods (default)\nmvn spring-boot:run -pl rest-api\n\n# OAuth2 only\nmvn spring-boot:run -pl rest-api -Dspring-boot.run.profiles=oauth2-only\n\n# Database authentication only  \nmvn spring-boot:run -pl rest-api -Dspring-boot.run.profiles=jdbc-only\n\n# LDAP authentication only\nmvn spring-boot:run -pl rest-api -Dspring-boot.run.profiles=ldap-only\n</code></pre>"},{"location":"security/common-security/#security-configuration-override","title":"Security Configuration Override","text":"<pre><code># application.yml\nspring:\n  security:\n    require-ssl: false  # Development only\n    headers:\n      frame-options: SAMEORIGIN\n      content-type-options: nosniff\n</code></pre>"},{"location":"security/common-security/#educational-highlights","title":"\ud83c\udf93 Educational Highlights","text":""},{"location":"security/common-security/#key-learning-concepts","title":"Key Learning Concepts","text":"<ol> <li>Profile-Based Configuration: How to create environment-specific security setups</li> <li>Multi-Provider Authentication: Combining different authentication mechanisms</li> <li>Filter Chain Integration: Proper JWT filter positioning</li> <li>Conditional Dependencies: Using <code>@Autowired(required = false)</code> for optional components</li> <li>Security Filter Ordering: Understanding Spring Security's filter execution order</li> </ol>"},{"location":"security/common-security/#best-practices-demonstrated","title":"Best Practices Demonstrated","text":"<p>\u2705 Separation of Concerns: Each authentication method in its own module \u2705 Profile-Based Deployment: Different security for different environments \u2705 Defensive Programming: Null checks for optional components \u2705 Stateless Design: JWT for APIs, sessions for web forms \u2705 Role-Based Security: Clear authorization rules  </p>"},{"location":"security/common-security/#integration-points","title":"\ud83d\udd17 Integration Points","text":""},{"location":"security/common-security/#dependencies","title":"Dependencies","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;common-auth&lt;/artifactId&gt;\n    &lt;version&gt;${project.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"security/common-security/#module-interactions","title":"Module Interactions","text":"<pre><code>graph LR\n    A[common-security] --&gt; B[common-auth]\n    A --&gt; C[jdbc-auth]\n    A --&gt; D[ldap-auth]\n    A --&gt; E[oauth2-auth]\n    F[rest-api] --&gt; A</code></pre>"},{"location":"security/common-security/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Security Filter Chain \u2192 - Deep dive into filter implementation</li> <li>Authorization \u2192 - Role-based access control patterns</li> <li>Authentication Methods \u2192 - Individual auth method details</li> <li>API Testing \u2192 - How to test security configurations</li> </ul> <p>\ud83d\udca1 The multi-profile approach allows this single configuration to support everything from development environments to production deployments with different authentication requirements.</p>"},{"location":"security/filter-chain/","title":"Security Filter Chain","text":"<p>Understanding Spring Security's filter chain is crucial for implementing custom authentication flows. This guide explores the filter chain architecture and custom filter integration in our reference project.</p>"},{"location":"security/filter-chain/#filter-chain-architecture","title":"\ud83d\udd17 Filter Chain Architecture","text":""},{"location":"security/filter-chain/#spring-security-filter-execution-order","title":"Spring Security Filter Execution Order","text":"<pre><code>graph TD\n    A[HTTP Request] --&gt; B[SecurityContextPersistenceFilter]\n    B --&gt; C[OAuth2LoginAuthenticationFilter]\n    C --&gt; D[JwtAuthenticationFilter - CUSTOM]\n    D --&gt; E[UsernamePasswordAuthenticationFilter]\n    E --&gt; F[BasicAuthenticationFilter]\n    F --&gt; G[AuthorizationFilter]\n    G --&gt; H[ExceptionTranslationFilter]\n    H --&gt; I[FilterSecurityInterceptor]\n    I --&gt; J[Controller]\n\n    B -.-&gt; K[Load SecurityContext from session]\n    C -.-&gt; L[Handle OAuth2 callbacks]\n    D -.-&gt; M[Validate JWT tokens]\n    E -.-&gt; N[Process login forms]\n    F -.-&gt; O[Handle Basic auth headers]\n    G -.-&gt; P[Check permissions]\n    H -.-&gt; Q[Handle security exceptions]</code></pre>"},{"location":"security/filter-chain/#filter-chain-configuration","title":"Filter Chain Configuration","text":"<p>Our security configuration carefully orchestrates multiple filters to support different authentication methods:</p> <pre><code>@Bean\npublic SecurityFilterChain defaultFilterChain(HttpSecurity http) throws Exception {\n    return http\n        // ... other configuration\n\n        // JWT Filter positioned BEFORE UsernamePasswordAuthenticationFilter\n        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n\n        // Multiple authentication providers\n        .authenticationProvider(customAuthenticationProvider)\n        .authenticationProvider(jdbcAuthenticationProvider)  \n        .authenticationProvider(ldapAuthenticationProvider)\n\n        .build();\n}\n</code></pre>"},{"location":"security/filter-chain/#custom-jwt-authentication-filter","title":"\ud83c\udfaf Custom JWT Authentication Filter","text":""},{"location":"security/filter-chain/#implementation-details","title":"Implementation Details","text":"<pre><code>@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws ServletException, IOException {\n\n        String header = request.getHeader(\"Authorization\");\n        String jwtToken = null;\n        String username = null;\n\n        // Extract JWT token from Authorization header\n        if (header != null &amp;&amp; header.startsWith(\"Bearer \")) {\n            jwtToken = header.substring(7);\n            try {\n                Claims claims = jwtTokenUtil.getClaimsFromToken(jwtToken);\n                username = claims.getSubject();\n                String role = claims.get(\"role\", String.class);\n\n                if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {\n                    // Create authorities from role\n                    List&lt;SimpleGrantedAuthority&gt; authorities = List.of(\n                        new SimpleGrantedAuthority(role)\n                    );\n\n                    // Create authentication token\n                    UsernamePasswordAuthenticationToken authToken =\n                            new UsernamePasswordAuthenticationToken(username, null, authorities);\n                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n                    // Set authentication in SecurityContext\n                    SecurityContextHolder.getContext().setAuthentication(authToken);\n                }\n            } catch (Exception e) {\n                logger.debug(\"Invalid JWT token: \" + e.getMessage());\n            }\n        }\n\n        // Continue filter chain\n        chain.doFilter(request, response);\n    }\n}\n</code></pre>"},{"location":"security/filter-chain/#filter-positioning-strategy","title":"Filter Positioning Strategy","text":"<pre><code>// JWT filter runs BEFORE form-based authentication\n.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n</code></pre> <p>Why this positioning? - JWT tokens should be processed before attempting form-based authentication - Allows stateless JWT authentication to take precedence - Enables fallback to other authentication methods if JWT is invalid</p>"},{"location":"security/filter-chain/#filter-chain-execution-flow","title":"\ud83d\udee1\ufe0f Filter Chain Execution Flow","text":""},{"location":"security/filter-chain/#successful-jwt-authentication","title":"Successful JWT Authentication","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant F as JwtAuthenticationFilter\n    participant S as SecurityContextHolder\n    participant A as AuthorizationFilter\n    participant R as Controller\n\n    C-&gt;&gt;F: Request with Authorization: Bearer &lt;token&gt;\n    F-&gt;&gt;F: Extract and validate JWT token\n    F-&gt;&gt;F: Extract username and role from claims\n    F-&gt;&gt;S: Set Authentication in SecurityContext\n    F-&gt;&gt;A: Continue filter chain\n    A-&gt;&gt;A: Check user permissions\n    A-&gt;&gt;R: Forward to controller\n    R-&gt;&gt;C: Response</code></pre>"},{"location":"security/filter-chain/#failed-jwt-authentication-with-fallback","title":"Failed JWT Authentication with Fallback","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant F as JwtAuthenticationFilter\n    participant U as UsernamePasswordAuthenticationFilter\n    participant P as AuthenticationProvider\n    participant R as Controller\n\n    C-&gt;&gt;F: Request with invalid/missing JWT\n    F-&gt;&gt;F: JWT validation fails or no token\n    F-&gt;&gt;U: Continue to next filter\n    U-&gt;&gt;P: Attempt username/password authentication\n    P-&gt;&gt;P: Validate credentials\n    P-&gt;&gt;R: Continue if successful\n    R-&gt;&gt;C: Response</code></pre>"},{"location":"security/filter-chain/#filter-configuration-by-profile","title":"\ud83d\udccb Filter Configuration by Profile","text":""},{"location":"security/filter-chain/#default-profile-filter-chain","title":"Default Profile Filter Chain","text":"<pre><code>@Profile(\"!oauth2-only &amp; !jdbc-only &amp; !ldap-only\")\npublic SecurityFilterChain defaultFilterChain(HttpSecurity http) {\n    // Supports ALL authentication methods:\n    // 1. JWT tokens (custom filter)\n    // 2. OAuth2 login (built-in filter)  \n    // 3. Database authentication (provider)\n    // 4. LDAP authentication (provider)\n    // 5. Custom authentication (provider)\n}\n</code></pre>"},{"location":"security/filter-chain/#oauth2-only-profile-filter-chain","title":"OAuth2-Only Profile Filter Chain","text":"<pre><code>@Profile(\"oauth2-only\")  \npublic SecurityFilterChain oauth2OnlyFilterChain(HttpSecurity http) {\n    // Only OAuth2 authentication:\n    // - OAuth2LoginAuthenticationFilter (built-in)\n    // - No custom JWT filter\n    // - No other authentication providers\n}\n</code></pre>"},{"location":"security/filter-chain/#jdbcldap-only-profile-filter-chain","title":"JDBC/LDAP-Only Profile Filter Chain","text":"<pre><code>@Profile(\"jdbc-only\") // or \"ldap-only\"\npublic SecurityFilterChain jdbcOnlyFilterChain(HttpSecurity http) {\n    // Form-based authentication only:\n    // - UsernamePasswordAuthenticationFilter (built-in)\n    // - Single authentication provider (JDBC or LDAP)\n    // - Session-based security context\n}\n</code></pre>"},{"location":"security/filter-chain/#filter-chain-debugging","title":"\ud83d\udd0d Filter Chain Debugging","text":""},{"location":"security/filter-chain/#logging-configuration","title":"Logging Configuration","text":"<p>Enable detailed filter chain logging:</p> <pre><code># application.yml\nlogging:\n  level:\n    org.springframework.security: DEBUG\n    org.springframework.security.web.FilterChainProxy: DEBUG\n    com.example.commonauth.JwtAuthenticationFilter: DEBUG\n</code></pre>"},{"location":"security/filter-chain/#filter-chain-analysis","title":"Filter Chain Analysis","text":"<p>Spring Security provides filter chain information at startup:</p> <pre><code>2024-01-15 10:30:15.123  INFO 12345 --- [main] o.s.s.web.DefaultSecurityFilterChain     \n: Will secure any request with filters:\n  SecurityContextPersistenceFilter\n  OAuth2LoginAuthenticationFilter  \n  JwtAuthenticationFilter (CUSTOM)\n  UsernamePasswordAuthenticationFilter\n  DefaultLoginPageGeneratingFilter\n  DefaultLogoutPageGeneratingFilter  \n  BasicAuthenticationFilter\n  RequestCacheAwareFilter\n  SecurityContextHolderAwareRequestFilter\n  AnonymousAuthenticationFilter\n  SessionManagementFilter\n  ExceptionTranslationFilter\n  AuthorizationFilter\n</code></pre>"},{"location":"security/filter-chain/#custom-filter-best-practices","title":"\ud83c\udfaf Custom Filter Best Practices","text":""},{"location":"security/filter-chain/#1-extend-onceperrequestfilter","title":"1. Extend OncePerRequestFilter","text":"<pre><code>@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n    // Ensures filter runs only once per request\n    // Handles async dispatches properly\n}\n</code></pre>"},{"location":"security/filter-chain/#2-null-safe-authentication-checks","title":"2. Null-Safe Authentication Checks","text":"<pre><code>// Only set authentication if none exists\nif (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {\n    // Set authentication\n}\n</code></pre>"},{"location":"security/filter-chain/#3-proper-exception-handling","title":"3. Proper Exception Handling","text":"<pre><code>try {\n    // Token validation logic\n} catch (Exception e) {\n    // Log but don't fail - let other filters try\n    logger.debug(\"Invalid JWT token: \" + e.getMessage());\n}\n// Always continue filter chain\nchain.doFilter(request, response);\n</code></pre>"},{"location":"security/filter-chain/#4-security-context-management","title":"4. Security Context Management","text":"<pre><code>// Create authentication with proper details\nUsernamePasswordAuthenticationToken authToken =\n        new UsernamePasswordAuthenticationToken(username, null, authorities);\nauthToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n// Set in SecurityContextHolder for this request\nSecurityContextHolder.getContext().setAuthentication(authToken);\n</code></pre>"},{"location":"security/filter-chain/#multi-protocol-filter-integration","title":"\ud83d\udd12 Multi-Protocol Filter Integration","text":""},{"location":"security/filter-chain/#grpc-security-interceptor","title":"gRPC Security Interceptor","text":"<pre><code>@Component\npublic class GrpcSecurityInterceptor implements ServerInterceptor {\n\n    @Override\n    public &lt;ReqT, RespT&gt; ServerCall.Listener&lt;ReqT&gt; interceptCall(\n            ServerCall&lt;ReqT, RespT&gt; call,\n            Metadata headers,\n            ServerCallHandler&lt;ReqT, RespT&gt; next) {\n\n        // Extract JWT from gRPC metadata\n        String authorization = headers.get(Metadata.Key.of(\"authorization\", ASCII_STRING_MARSHALLER));\n\n        if (authorization != null &amp;&amp; authorization.startsWith(\"Bearer \")) {\n            // Validate JWT and set security context\n            // Similar to HTTP JWT filter logic\n        }\n\n        return next.startCall(call, headers);\n    }\n}\n</code></pre>"},{"location":"security/filter-chain/#websocket-security-interceptor","title":"WebSocket Security Interceptor","text":"<pre><code>@Component\npublic class WebSocketSecurityInterceptor implements ChannelInterceptor {\n\n    @Override\n    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {\n        // WebSocket message-level security\n        // Can validate JWT tokens in WebSocket messages\n        return message;\n    }\n}\n</code></pre>"},{"location":"security/filter-chain/#educational-concepts","title":"\ud83d\udcda Educational Concepts","text":""},{"location":"security/filter-chain/#filter-vs-provider","title":"Filter vs Provider","text":"Component Purpose When to Use Filter Process requests/responses Custom token validation, header processing Provider Authenticate credentials Database lookups, external service calls"},{"location":"security/filter-chain/#filter-ordering","title":"Filter Ordering","text":"<pre><code>// Critical ordering principles:\n// 1. Authentication filters before authorization\n// 2. Custom filters before built-in equivalents  \n// 3. Token-based before credential-based\n// 4. Stateless before stateful\n\n.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n</code></pre>"},{"location":"security/filter-chain/#securitycontext-lifecycle","title":"SecurityContext Lifecycle","text":"<ol> <li>Request Start: SecurityContext loaded from session (if exists)</li> <li>Filter Chain: Filters populate authentication</li> <li>Authorization: Access control decisions made</li> <li>Request End: SecurityContext cleared (stateless) or saved (stateful)</li> </ol>"},{"location":"security/filter-chain/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li>Authorization \u2192 - Role-based access control after authentication</li> <li>JWT Authentication \u2192 - Detailed JWT implementation</li> <li>Testing Security \u2192 - How to test filter chains</li> <li>API Reference \u2192 - Authentication flow documentation</li> </ul> <p>\ud83d\udca1 The filter chain is where authentication happens, but authorization decisions are made later in the process. Understanding this separation is key to Spring Security mastery.</p>"},{"location":"security/use-cases/","title":"Use Cases","text":"<p>...existing code (starting from the first non-duplicate section)...</p> <pre><code>// E-commerce Mobile App\n@RestController\npublic class OrderController {\n    @GetMapping(\"/api/orders\")\n    @PreAuthorize(\"hasRole('CUSTOMER')\")\n    public List&lt;Order&gt; getOrders(Authentication auth) {\n        String userId = auth.getName();\n        return orderService.findByUserId(userId);\n    }\n}\n\n// Microservices Communication\n@Component\npublic class PaymentServiceClient {\n    public PaymentResult processPayment(String jwtToken, PaymentRequest request) {\n        return webClient.post()\n            .uri(\"/payment/process\")\n            .header(\"Authorization\", \"Bearer \" + jwtToken)\n            .bodyValue(request)\n            .retrieve()\n            .bodyToMono(PaymentResult.class)\n            .block();\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#2-session-based-authentication","title":"2. Session-Based Authentication","text":""},{"location":"security/use-cases/#industry-use-cases","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Traditional Web Applications: Server-side rendered pages - Enterprise Intranets: Internal company portals - Admin Dashboards: CMS, analytics platforms - E-learning Platforms: Course management systems - Banking Web Portals: Where session security is critical</p> <p>\u274c Not Suitable For: - Mobile Applications: No cookie support - Microservices: Stateful, doesn't scale - Public APIs: Not stateless - Cross-Domain Apps: Cookie limitations</p>"},{"location":"security/use-cases/#api-protocol-support","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Cookie-based)\nGraphQL: \u2705 Excellent (Cookie-based)\ngRPC: \u274c Not Suitable (No cookie support)\nWebSocket: \u2705 Excellent (Cookie upgrade)\nSSE: \u2705 Excellent (Cookie-based)\nWebhooks: \u274c Not Applicable\nWebRTC: \u274c Not Suitable\nCoAP: \u274c Not Suitable\nMQTT: \u274c Not Suitable\n</code></pre>"},{"location":"security/use-cases/#real-world-examples","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// E-commerce Admin Portal\n@Controller\npublic class AdminController {\n    @GetMapping(\"/admin/dashboard\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public String dashboard(Model model, HttpSession session) {\n        String adminUser = (String) session.getAttribute(\"username\");\n        model.addAttribute(\"welcomeMessage\", \"Welcome \" + adminUser);\n        return \"admin-dashboard\";\n    }\n}\n\n// Banking Web Portal with CSRF Protection\n@Configuration\n@EnableWebSecurity\npublic class BankingSecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n            .sessionManagement(session -&gt; \n                session.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n                       .maximumSessions(1)\n                       .maxSessionsPreventsLogin(true))\n            .csrf(csrf -&gt; csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))\n            .build();\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#3-jdbc-database-authentication","title":"3. JDBC Database Authentication","text":""},{"location":"security/use-cases/#industry-use-cases_1","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Small-Medium Business Applications: CRM, inventory systems - Internal Corporate Tools: HR systems, project management - Startup MVPs: Quick user management setup - Legacy System Modernization: Existing database integration - Departmental Applications: Team-specific tools</p> <p>\u274c Not Suitable For: - High-Scale Consumer Apps: Performance bottlenecks - Enterprise SSO Integration: Use LDAP instead - Microservices: Distributed auth complexity - Real-time Applications: Database latency</p>"},{"location":"security/use-cases/#api-protocol-support_1","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Basic/Form auth)\nGraphQL: \u2705 Good (Basic auth)\ngRPC: \u2705 Moderate (Basic auth metadata)\nWebSocket: \u2705 Good (Initial handshake)\nSSE: \u2705 Good (Basic auth)\nWebhooks: \u26a0\ufe0f Limited (Receiving validation)\nWebRTC: \u274c Not Suitable\nCoAP: \u2705 Moderate (Basic auth)\nMQTT: \u2705 Good (Username/password)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_1","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Small Business CRM System\n@RestController\npublic class CustomerController {\n    @GetMapping(\"/api/customers\")\n    @PreAuthorize(\"hasRole('SALES_REP')\")\n    public List&lt;Customer&gt; getCustomers(Authentication auth) {\n        String salesRep = auth.getName();\n        return customerService.findByAssignedSalesRep(salesRep);\n    }\n}\n\n// Inventory Management System\n@Configuration\npublic class InventorySecurityConfig {\n    @Bean\n    public JdbcUserDetailsManager users(DataSource dataSource) {\n        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);\n\n        // Custom queries for inventory-specific roles\n        manager.setUsersByUsernameQuery(\n            \"SELECT username, password, enabled FROM inventory_users WHERE username = ?\"\n        );\n        manager.setAuthoritiesByUsernameQuery(\n            \"SELECT u.username, r.role_name FROM inventory_users u \" +\n            \"JOIN user_roles ur ON u.id = ur.user_id \" +\n            \"JOIN roles r ON ur.role_id = r.id WHERE u.username = ?\"\n        );\n\n        return manager;\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#4-ldap-authentication","title":"4. LDAP Authentication","text":""},{"location":"security/use-cases/#industry-use-cases_2","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Enterprise Applications: Large corporations with Active Directory - University Systems: Student/faculty management - Government Applications: Federal/state departments - Healthcare Systems: Hospital management with AD integration - Financial Services: Banks with existing LDAP infrastructure</p> <p>\u274c Not Suitable For: - Consumer Applications: No LDAP infrastructure - Small Businesses: Overkill for small teams - Mobile-First Apps: Complex integration - Public APIs: External users don't have LDAP</p>"},{"location":"security/use-cases/#api-protocol-support_2","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Basic auth with LDAP backend)\nGraphQL: \u2705 Good (LDAP authentication)\ngRPC: \u2705 Moderate (LDAP via interceptors)\nWebSocket: \u2705 Good (LDAP handshake)\nSSE: \u2705 Good (LDAP authentication)\nWebhooks: \u26a0\ufe0f Limited (Internal webhooks only)\nWebRTC: \u26a0\ufe0f Limited (Signaling auth)\nCoAP: \u26a0\ufe0f Limited (Custom LDAP integration)\nMQTT: \u26a0\ufe0f Moderate (LDAP username validation)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_2","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Enterprise HR System\n@RestController\npublic class EmployeeController {\n    @GetMapping(\"/api/employees/{department}\")\n    @PreAuthorize(\"hasRole('HR_MANAGER') or hasRole('DEPARTMENT_HEAD')\")\n    public List&lt;Employee&gt; getDepartmentEmployees(@PathVariable String department, \n                                               Authentication auth) {\n        // LDAP provides department information automatically\n        LdapUserDetails userDetails = (LdapUserDetails) auth.getPrincipal();\n        String userDepartment = userDetails.getDn().getValue(\"ou\");\n\n        if (hasRole(\"HR_MANAGER\") || userDepartment.equals(department)) {\n            return employeeService.findByDepartment(department);\n        }\n        throw new AccessDeniedException(\"Cannot access other departments\");\n    }\n}\n\n// University Course Management\n@Configuration\npublic class UniversityLdapConfig {\n    @Bean\n    public LdapContextSource contextSource() {\n        LdapContextSource contextSource = new LdapContextSource();\n        contextSource.setUrl(\"ldap://university-ad.edu:389\");\n        contextSource.setBase(\"dc=university,dc=edu\");\n        contextSource.setUserDn(\"cn=app-service,ou=services,dc=university,dc=edu\");\n        contextSource.setPassword(\"service-password\");\n        return contextSource;\n    }\n\n    @Bean\n    public LdapAuthenticationProvider ldapAuthProvider() {\n        return new LdapAuthenticationProvider(\n            new BindAuthenticator(contextSource()),\n            new DefaultLdapAuthoritiesPopulator(contextSource(), \"ou=groups\")\n        );\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#5-oauth2-social-login","title":"5. OAuth2 / Social Login","text":""},{"location":"security/use-cases/#industry-use-cases_3","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Consumer Applications: Social media apps, games - B2C E-commerce: Customer-facing online stores - Content Platforms: Blogs, forums, media sites - Developer Tools: GitHub integration, API platforms - Third-Party Integrations: Apps connecting to Google/Microsoft</p> <p>\u274c Not Suitable For: - High-Security Applications: Military, banking core systems - Air-Gapped Systems: No internet connectivity - Simple Internal Tools: Overkill for basic auth - Legacy Enterprise: May not support external OAuth</p>"},{"location":"security/use-cases/#api-protocol-support_3","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Standard OAuth2 flows)\nGraphQL: \u2705 Excellent (Bearer tokens)\ngRPC: \u2705 Good (OAuth2 tokens in metadata)\nWebSocket: \u2705 Good (OAuth2 token in upgrade)\nSSE: \u2705 Good (OAuth2 in headers)\nWebhooks: \u2705 Excellent (OAuth2 for callback auth)\nWebRTC: \u26a0\ufe0f Moderate (OAuth2 for signaling)\nCoAP: \u26a0\ufe0f Limited (Custom OAuth2 implementation)\nMQTT: \u26a0\ufe0f Limited (OAuth2 tokens as passwords)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_3","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Social Media Platform\n@RestController\npublic class SocialController {\n    @GetMapping(\"/api/profile\")\n    @PreAuthorize(\"hasAuthority('SCOPE_profile')\")\n    public UserProfile getProfile(OAuth2Authentication auth) {\n        OAuth2AuthenticationDetails details = \n            (OAuth2AuthenticationDetails) auth.getDetails();\n        String socialId = (String) details.getDecodedDetails().get(\"sub\");\n\n        return profileService.findBySocialId(socialId);\n    }\n}\n\n// E-commerce with Google Pay Integration\n@RestController\npublic class CheckoutController {\n    @PostMapping(\"/api/checkout/google-pay\")\n    public PaymentResult processGooglePay(@RequestBody GooglePayRequest request,\n                                        OAuth2Authentication auth) {\n        // Verify Google OAuth2 token has payment scope\n        if (!auth.getAuthorities().stream()\n                .anyMatch(a -&gt; a.getAuthority().equals(\"SCOPE_payments\"))) {\n            throw new InsufficientScopeException(\"Payment scope required\");\n        }\n\n        return googlePayService.processPayment(request);\n    }\n}\n\n// Developer API Platform\n@Configuration\n@EnableOAuth2ResourceServer\npublic class ApiPlatformConfig {\n    @Bean\n    public SecurityFilterChain resourceServerFilterChain(HttpSecurity http) throws Exception {\n        return http\n            .oauth2ResourceServer(oauth2 -&gt; oauth2\n                .jwt(jwt -&gt; jwt.decoder(jwtDecoder()))\n                .accessDeniedHandler(new OAuth2AccessDeniedHandler())\n            )\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasAuthority(\"SCOPE_admin\")\n                .requestMatchers(\"/api/user/**\").hasAuthority(\"SCOPE_user\")\n                .anyRequest().authenticated()\n            )\n            .build();\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#6-api-keys","title":"6. API Keys","text":""},{"location":"security/use-cases/#industry-use-cases_4","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Public APIs: Weather, maps, payment gateways - IoT Devices: Sensors, smart home devices - Batch Processing: Data pipelines, ETL jobs - Service Monitoring: Health checks, metrics collection - Third-Party Integrations: External service connections</p> <p>\u274c Not Suitable For: - User-Facing Applications: No user identity - High-Security Transactions: Insufficient security - Complex Authorization: No role-based access - Session Management: Stateless only</p>"},{"location":"security/use-cases/#api-protocol-support_4","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Header/query param)\nGraphQL: \u2705 Excellent (Header-based)\ngRPC: \u2705 Excellent (Metadata headers)\nWebSocket: \u2705 Good (Connection headers)\nSSE: \u2705 Good (Query parameters)\nWebhooks: \u2705 Excellent (Signature verification)\nWebRTC: \u26a0\ufe0f Limited (Signaling auth only)\nCoAP: \u2705 Excellent (Custom headers)\nMQTT: \u2705 Good (Username field)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_4","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Weather API Service\n@RestController\npublic class WeatherController {\n    @GetMapping(\"/api/weather/{city}\")\n    public WeatherData getWeather(@PathVariable String city,\n                                 @RequestHeader(\"X-API-Key\") String apiKey) {\n        if (!apiKeyService.isValid(apiKey)) {\n            throw new UnauthorizedException(\"Invalid API key\");\n        }\n\n        ApiKeyInfo keyInfo = apiKeyService.getKeyInfo(apiKey);\n        if (keyInfo.hasExceededRateLimit()) {\n            throw new RateLimitExceededException(\"Rate limit exceeded\");\n        }\n\n        return weatherService.getWeatherData(city);\n    }\n}\n\n// IoT Device Communication\n@Component\npublic class IoTDeviceAuthFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, \n                        FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n\n        String deviceId = httpRequest.getHeader(\"X-Device-ID\");\n        String apiKey = httpRequest.getHeader(\"X-Device-Key\");\n\n        if (deviceAuthService.validateDevice(deviceId, apiKey)) {\n            // Create device-specific security context\n            DeviceAuthentication auth = new DeviceAuthentication(deviceId);\n            SecurityContextHolder.getContext().setAuthentication(auth);\n            chain.doFilter(request, response);\n        } else {\n            ((HttpServletResponse) response).setStatus(HttpStatus.UNAUTHORIZED.value());\n        }\n    }\n}\n\n// Webhook Signature Verification\n@RestController\npublic class WebhookController {\n    @PostMapping(\"/webhooks/payment\")\n    public ResponseEntity&lt;String&gt; handlePaymentWebhook(\n            @RequestBody String payload,\n            @RequestHeader(\"X-Signature\") String signature,\n            @RequestHeader(\"X-API-Key\") String apiKey) {\n\n        if (!webhookService.verifySignature(payload, signature, apiKey)) {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                .body(\"Invalid signature\");\n        }\n\n        paymentService.processWebhookEvent(payload);\n        return ResponseEntity.ok(\"Processed\");\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#7-mtls-mutual-tls","title":"7. mTLS (Mutual TLS)","text":""},{"location":"security/use-cases/#industry-use-cases_5","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Banking &amp; Financial Services: Core banking systems - Healthcare Systems: HIPAA-compliant applications - Government &amp; Military: Classified system communications - B2B Enterprise Integration: Secure partner APIs - Microservices in Zero-Trust Architecture: Service mesh security</p> <p>\u274c Not Suitable For: - Public Consumer APIs: Certificate management complexity - Mobile Applications: Certificate distribution challenges - Development/Testing: Too complex for rapid iteration - Small-Scale Applications: Operational overhead</p>"},{"location":"security/use-cases/#api-protocol-support_5","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (HTTPS with client certs)\nGraphQL: \u2705 Excellent (HTTPS with client certs)\ngRPC: \u2705 Excellent (Native TLS support)\nWebSocket: \u2705 Good (WSS with client certs)\nSSE: \u2705 Good (HTTPS with client certs)\nWebhooks: \u2705 Excellent (Mutual verification)\nWebRTC: \u2705 Good (DTLS for data channels)\nCoAP: \u2705 Good (DTLS support)\nMQTT: \u2705 Good (TLS with client certs)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_5","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Banking Core System\n@Configuration\n@EnableWebSecurity\npublic class BankingSecurityConfig {\n    @Bean\n    public SecurityFilterChain mtlsFilterChain(HttpSecurity http) throws Exception {\n        return http\n            .requiresChannel(channel -&gt; \n                channel.requestMatchers(\"/api/banking/**\").requiresSecure())\n            .x509(x509 -&gt; x509\n                .subjectPrincipalRegex(\"CN=(.*?)(?:,|$)\")\n                .userDetailsService(bankingX509UserDetailsService())\n            )\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(\"/api/banking/transfer\").hasRole(\"BANKING_SYSTEM\")\n                .requestMatchers(\"/api/banking/balance\").hasRole(\"ACCOUNT_SERVICE\")\n                .anyRequest().denyAll()\n            )\n            .build();\n    }\n\n    @Bean\n    public X509UserDetailsService bankingX509UserDetailsService() {\n        return new X509UserDetailsService() {\n            @Override\n            public UserDetails loadUserByUsername(String username) {\n                // Username extracted from certificate CN\n                if (\"core-banking-service\".equals(username)) {\n                    return User.withUsername(username)\n                        .password(\"\") // Not used for certificate auth\n                        .authorities(\"ROLE_BANKING_SYSTEM\")\n                        .build();\n                }\n                throw new UsernameNotFoundException(\"Unknown service: \" + username);\n            }\n        };\n    }\n}\n\n// Healthcare HIPAA-Compliant API\n@RestController\npublic class PatientController {\n    @GetMapping(\"/api/patients/{patientId}\")\n    @PreAuthorize(\"hasRole('HEALTHCARE_PROVIDER')\")\n    public PatientRecord getPatientRecord(@PathVariable String patientId,\n                                        X509Authentication auth) {\n        X509Certificate clientCert = auth.getCredentials();\n        String organizationUnit = getOrganizationUnit(clientCert);\n\n        // Verify the requesting system is authorized for this patient\n        if (!patientAuthService.canAccess(organizationUnit, patientId)) {\n            throw new AccessDeniedException(\"Unauthorized patient access\");\n        }\n\n        return patientService.getPatientRecord(patientId);\n    }\n}\n\n// Microservices Service Mesh Communication\n@Component\npublic class ServiceMeshClient {\n    private final WebClient webClient;\n\n    public ServiceMeshClient() {\n        SslContext sslContext = SslContextBuilder.forClient()\n            .keyManager(getClientCertificate(), getClientPrivateKey())\n            .trustManager(getTrustedCertificates())\n            .build();\n\n        HttpClient httpClient = HttpClient.create()\n            .secure(sslSpec -&gt; sslSpec.sslContext(sslContext));\n\n        this.webClient = WebClient.builder()\n            .clientConnector(new ReactorClientHttpConnector(httpClient))\n            .build();\n    }\n\n    public Mono&lt;OrderResponse&gt; callOrderService(OrderRequest request) {\n        return webClient.post()\n            .uri(\"https://order-service:8443/api/orders\")\n            .bodyValue(request)\n            .retrieve()\n            .bodyToMono(OrderResponse.class);\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#8-custom-token-authentication","title":"8. Custom Token Authentication","text":""},{"location":"security/use-cases/#industry-use-cases_6","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Gaming Platforms: Session tokens, achievement systems - Proprietary Protocols: Custom B2B integrations - Legacy System Integration: Non-standard authentication - High-Performance Systems: Optimized token formats - Specialized Industries: Unique compliance requirements</p> <p>\u274c Not Suitable For: - Standard Web Applications: Use established standards - Interoperability Requirements: Stick to OAuth2/JWT - Small Development Teams: Maintenance overhead - Audit/Compliance Heavy: Standards preferred</p>"},{"location":"security/use-cases/#api-protocol-support_6","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Custom headers)\nGraphQL: \u2705 Excellent (Custom headers)\ngRPC: \u2705 Excellent (Custom metadata)\nWebSocket: \u2705 Excellent (Custom protocols)\nSSE: \u2705 Good (Custom headers)\nWebhooks: \u2705 Good (Custom signatures)\nWebRTC: \u2705 Good (Custom signaling)\nCoAP: \u2705 Excellent (Custom options)\nMQTT: \u2705 Good (Custom auth fields)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_6","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Gaming Platform with Custom Session Tokens\n@RestController\npublic class GameController {\n    @PostMapping(\"/api/game/action\")\n    public GameActionResult performAction(@RequestBody GameAction action,\n                                        @RequestHeader(\"X-Game-Token\") String gameToken) {\n        GameSession session = gameTokenService.validateAndRefresh(gameToken);\n\n        if (session.hasExpired()) {\n            throw new GameSessionExpiredException(\"Session expired, please rejoin\");\n        }\n\n        if (!session.getPlayer().canPerformAction(action.getType())) {\n            throw new InsufficientPermissionsException(\"Action not allowed\");\n        }\n\n        return gameEngine.processAction(session.getPlayerId(), action);\n    }\n}\n\n// High-Performance Trading System\n@Component\npublic class TradingAuthFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, \n                        FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n\n        String tradingToken = httpRequest.getHeader(\"X-Trading-Token\");\n        if (tradingToken != null) {\n            // Custom token format: TRADER_ID|TIMESTAMP|SIGNATURE\n            TradingCredentials creds = tradingTokenService.parseToken(tradingToken);\n\n            if (tradingTokenService.isValidSignature(creds) &amp;&amp; \n                creds.getTimestamp() &gt; (System.currentTimeMillis() - 30000)) { // 30s expiry\n\n                TradingAuthentication auth = new TradingAuthentication(\n                    creds.getTraderId(), \n                    creds.getPermissions()\n                );\n                SecurityContextHolder.getContext().setAuthentication(auth);\n                chain.doFilter(request, response);\n                return;\n            }\n        }\n\n        ((HttpServletResponse) response).setStatus(HttpStatus.UNAUTHORIZED.value());\n    }\n}\n\n// Legacy System Integration\n@Service\npublic class LegacySystemAdapter {\n    public void authenticateWithLegacySystem(String customToken) {\n        // Parse proprietary token format\n        LegacyTokenData tokenData = legacyTokenParser.parse(customToken);\n\n        // Validate with legacy authentication service\n        if (legacyAuthService.validateToken(tokenData)) {\n            // Convert to Spring Security authentication\n            LegacyAuthentication auth = new LegacyAuthentication(\n                tokenData.getUserId(),\n                tokenData.getDepartment(),\n                tokenData.getRoles()\n            );\n            SecurityContextHolder.getContext().setAuthentication(auth);\n        }\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#9-saml-security-assertion-markup-language","title":"9. SAML (Security Assertion Markup Language)","text":""},{"location":"security/use-cases/#industry-use-cases_7","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Enterprise Single Sign-On: Large organizations with existing SAML infrastructure - Educational Institutions: University systems with federated identity - Government Applications: Inter-agency authentication - Healthcare Networks: Hospital system integration - B2B Partner Integration: Secure partner access</p> <p>\u274c Not Suitable For: - Mobile Applications: XML overhead, complexity - Modern Web APIs: REST/JSON preferred - Small Organizations: Setup complexity - Real-time Applications: XML processing overhead</p>"},{"location":"security/use-cases/#api-protocol-support_7","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Good (SAML assertions for auth)\nGraphQL: \u2705 Moderate (SAML session-based)\ngRPC: \u274c Not Suitable (XML overhead)\nWebSocket: \u26a0\ufe0f Limited (Initial SAML handshake)\nSSE: \u26a0\ufe0f Limited (Session-based only)\nWebhooks: \u274c Not Applicable\nWebRTC: \u274c Not Suitable\nCoAP: \u274c Not Suitable\nMQTT: \u274c Not Suitable\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_7","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Enterprise Portal with SAML SSO\n@Configuration\n@EnableWebSecurity\npublic class EnterprisePortalConfig {\n    @Bean\n    public SecurityFilterChain samlFilterChain(HttpSecurity http) throws Exception {\n        return http\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(\"/saml/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .saml2Login(saml2 -&gt; saml2\n                .relyingPartyRegistrationRepository(relyingPartyRegistrations())\n                .userDetailsService(samlUserDetailsService())\n            )\n            .saml2Logout(saml2 -&gt; saml2\n                .logoutRequest(request -&gt; request\n                    .logoutUrl(\"/saml2/logout\")\n                )\n                .logoutResponse(response -&gt; response\n                    .logoutUrl(\"/saml2/logout\")\n                )\n            )\n            .build();\n    }\n\n    @Bean\n    public UserDetailsService samlUserDetailsService() {\n        return new Saml2UserDetailsService() {\n            @Override\n            public UserDetails loadUserBySaml2User(Saml2User saml2User) {\n                String email = saml2User.getAttribute(\"email\");\n                String department = saml2User.getAttribute(\"department\");\n                List&lt;String&gt; roles = saml2User.getAttribute(\"roles\");\n\n                return User.withUsername(email)\n                    .password(\"\") // Not used for SAML\n                    .authorities(roles.stream()\n                        .map(role -&gt; new SimpleGrantedAuthority(\"ROLE_\" + role))\n                        .collect(Collectors.toList()))\n                    .build();\n            }\n        };\n    }\n}\n\n// University System with Federated Identity\n@RestController\npublic class AcademicController {\n    @GetMapping(\"/api/courses/enrolled\")\n    @PreAuthorize(\"hasRole('STUDENT') or hasRole('FACULTY')\")\n    public List&lt;Course&gt; getEnrolledCourses(Authentication auth) {\n        Saml2AuthenticatedPrincipal principal = \n            (Saml2AuthenticatedPrincipal) auth.getPrincipal();\n\n        String studentId = principal.getAttribute(\"studentId\");\n        String university = principal.getAttribute(\"institution\");\n\n        // Cross-university enrollment support\n        return courseService.findEnrollments(studentId, university);\n    }\n}\n\n// Healthcare Network Integration\n@Service\npublic class HealthcareNetworkService {\n    public PatientData getPatientFromPartnerHospital(String patientId, \n                                                   Saml2Authentication samlAuth) {\n        Saml2AuthenticatedPrincipal principal = samlAuth.getPrincipal();\n\n        String requestingHospital = principal.getAttribute(\"organization\");\n        String physicianLicense = principal.getAttribute(\"licenseNumber\");\n\n        // Verify inter-hospital data sharing agreements\n        if (!dataSharingService.isAuthorized(requestingHospital, physicianLicense)) {\n            throw new AccessDeniedException(\"No data sharing agreement\");\n        }\n\n        return partnerHospitalClient.getPatientData(patientId, samlAuth);\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#10-cross-application-sso-single-sign-on","title":"10. Cross-Application SSO (Single Sign-On)","text":""},{"location":"security/use-cases/#industry-use-cases_8","title":"\ud83c\udfed Industry Use Cases","text":"<p>\u2705 Best For: - Corporate Application Suites: Office 365, Google Workspace alternatives - Educational Platforms: Student portals accessing multiple university systems - Healthcare Networks: EMR systems with multiple integrated applications - E-commerce Ecosystems: Main site + blog + support + admin portals - Multi-Tenant SaaS Platforms: Different applications under single tenant</p> <p>\u274c Not Suitable For: - Single Application Systems: No multiple apps to integrate - Highly Isolated Systems: Security requires separate authentication - Different Security Domains: Cross-organization without federation - Legacy Systems: May not support modern SSO protocols</p>"},{"location":"security/use-cases/#api-protocol-support_8","title":"\ud83d\udce1 API Protocol Support","text":"<pre><code>REST APIs: \u2705 Excellent (Session/JWT sharing)\nGraphQL: \u2705 Excellent (Same auth context)\ngRPC: \u2705 Good (JWT token propagation)\nWebSocket: \u2705 Good (Session-based SSO)\nSSE: \u2705 Good (Session-based SSO)\nWebhooks: \u26a0\ufe0f Limited (Cross-app notifications)\nWebRTC: \u26a0\ufe0f Moderate (Signaling auth sharing)\nCoAP: \u26a0\ufe0f Limited (Custom SSO implementation)\nMQTT: \u26a0\ufe0f Limited (Shared credentials)\n</code></pre>"},{"location":"security/use-cases/#real-world-examples_8","title":"\ud83c\udfe2 Real-World Examples","text":"<pre><code>// Corporate Application Suite SSO\n@RestController\npublic class SSOController {\n\n    @PostMapping(\"/sso/authenticate\")\n    public ResponseEntity&lt;SSOTokenResponse&gt; authenticateForSSO(\n            @RequestBody SSOLoginRequest request) {\n\n        // Authenticate user with primary method (LDAP/OAuth2)\n        Authentication auth = authenticationManager.authenticate(\n            new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())\n        );\n\n        if (auth.isAuthenticated()) {\n            // Generate SSO token for cross-application use\n            SSOToken ssoToken = ssoTokenService.generateSSOToken(auth);\n\n            // Store in distributed session store (Redis/Hazelcast)\n            distributedSessionStore.put(ssoToken.getSessionId(), auth);\n\n            return ResponseEntity.ok(new SSOTokenResponse(\n                ssoToken.getToken(),\n                ssoToken.getExpiryTime(),\n                getAuthorizedApplications(auth)\n            ));\n        }\n\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();\n    }\n}\n\n// Multi-Application Authentication Filter\n@Component\npublic class SSOAuthenticationFilter extends OncePerRequestFilter {\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, \n                                   HttpServletResponse response, \n                                   FilterChain filterChain) throws ServletException, IOException {\n\n        String ssoToken = extractSSOToken(request);\n\n        if (ssoToken != null) {\n            try {\n                // Validate SSO token with central SSO service\n                SSOValidationResponse validation = ssoService.validateToken(ssoToken, getCurrentApplicationId());\n\n                if (validation.isValid()) {\n                    // Create authentication context for this application\n                    Collection&lt;SimpleGrantedAuthority&gt; authorities = validation.getRoles().stream()\n                        .map(role -&gt; new SimpleGrantedAuthority(\"ROLE_\" + role))\n                        .collect(Collectors.toList());\n\n                    SSOAuthentication auth = new SSOAuthentication(\n                        validation.getUsername(),\n                        authorities,\n                        ssoToken\n                    );\n\n                    SecurityContextHolder.getContext().setAuthentication(auth);\n                }\n            } catch (Exception e) {\n                log.debug(\"SSO authentication failed\", e);\n                // Fall back to regular authentication methods\n            }\n        }\n\n        filterChain.doFilter(request, response);\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#protocol-specific-security-patterns","title":"\ud83d\udd04 Protocol-Specific Security Patterns","text":""},{"location":"security/use-cases/#rest-apis","title":"REST APIs","text":"<pre><code>// Multi-auth support for different client types\n@Configuration\npublic class RestApiSecurityConfig {\n    @Bean\n    public SecurityFilterChain restFilterChain(HttpSecurity http) throws Exception {\n        return http\n            .securityMatchers(matchers -&gt; matchers\n                .requestMatchers(\"/api/**\"))\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/mobile/**\").hasAuthority(\"SCOPE_mobile\")  // OAuth2\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")               // Session/JWT\n                .requestMatchers(\"/api/partner/**\").hasRole(\"PARTNER_SYSTEM\")    // mTLS\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()))\n            .sessionManagement(session -&gt; session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            .build();\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#graphql","title":"GraphQL","text":"<pre><code>@Component\npublic class GraphQLSecurityConfig {\n    @EventListener\n    public void configureGraphQLSecurity(GraphQLServletListener.RequestCallback callback) {\n        callback.addDataFetcherExceptionResolver((ex, env) -&gt; {\n            if (ex instanceof AccessDeniedException) {\n                return DataFetcherExceptionResolverAdapter\n                    .createResult(\"Access denied: \" + ex.getMessage());\n            }\n            return null;\n        });\n    }\n}\n\n@Component\npublic class GraphQLAuthDirective implements SchemaDirectiveWiring {\n    @Override\n    public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) {\n        String requiredRole = env.getDirective().getArgument(\"role\").getValue();\n\n        DataFetcher&lt;?&gt; originalDataFetcher = env.getCodeRegistry()\n            .getDataFetcher(env.getFieldsContainer(), env.getFieldDefinition());\n\n        DataFetcher&lt;?&gt; authDataFetcher = (fetcherEnv) -&gt; {\n            Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n            if (auth == null || !auth.getAuthorities().stream()\n                    .anyMatch(a -&gt; a.getAuthority().equals(\"ROLE_\" + requiredRole))) {\n                throw new AccessDeniedException(\"Insufficient privileges\");\n            }\n            return originalDataFetcher.get(fetcherEnv);\n        };\n\n        env.getCodeRegistry().dataFetcher(env.getFieldsContainer(), \n                                        env.getFieldDefinition(), authDataFetcher);\n        return env.getElement();\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#grpc","title":"gRPC","text":"<pre><code>@Component\npublic class GrpcSecurityInterceptor implements ServerInterceptor {\n    @Override\n    public &lt;ReqT, RespT&gt; ServerCall.Listener&lt;ReqT&gt; interceptCall(\n            ServerCall&lt;ReqT, RespT&gt; call, Metadata headers, ServerCallHandler&lt;ReqT, RespT&gt; next) {\n\n        String authorization = headers.get(Metadata.Key.of(\"Authorization\", ASCII_STRING_MARSHALLER));\n\n        try {\n            Authentication auth = null;\n\n            if (authorization != null) {\n                if (authorization.startsWith(\"Bearer \")) {\n                    // JWT Token\n                    String token = authorization.substring(7);\n                    auth = jwtAuthenticationProvider.authenticate(\n                        new JwtAuthenticationToken(token));\n                } else if (authorization.startsWith(\"Basic \")) {\n                    // Basic Auth (LDAP/JDBC)\n                    auth = basicAuthenticationProvider.authenticate(\n                        parseBasicAuth(authorization));\n                }\n            }\n\n            if (auth != null &amp;&amp; auth.isAuthenticated()) {\n                SecurityContextHolder.getContext().setAuthentication(auth);\n                return next.startCall(call, headers);\n            }\n\n        } catch (Exception e) {\n            call.close(Status.UNAUTHENTICATED.withDescription(\"Authentication failed\"), new Metadata());\n            return new ServerCall.Listener&lt;ReqT&gt;() {};\n        }\n\n        call.close(Status.UNAUTHENTICATED.withDescription(\"Missing authentication\"), new Metadata());\n        return new ServerCall.Listener&lt;ReqT&gt;() {};\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#websocket","title":"WebSocket","text":"<pre><code>@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketSecurityConfig implements WebSocketMessageBrokerConfigurer {\n\n    @Override\n    public void configureClientInboundChannel(ChannelRegistration registration) {\n        registration.interceptors(new ChannelInterceptor() {\n            @Override\n            public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {\n                StompHeaderAccessor accessor = \n                    MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n\n                if (StompCommand.CONNECT.equals(accessor.getCommand())) {\n                    String token = accessor.getFirstNativeHeader(\"Authorization\");\n                    if (token != null &amp;&amp; token.startsWith(\"Bearer \")) {\n                        try {\n                            Authentication auth = jwtAuthenticationProvider\n                                .authenticate(new JwtAuthenticationToken(token.substring(7)));\n                            accessor.setUser(auth);\n                            SecurityContextHolder.getContext().setAuthentication(auth);\n                        } catch (Exception e) {\n                            throw new MessagingException(\"Authentication failed\");\n                        }\n                    } else {\n                        throw new MessagingException(\"Missing authentication token\");\n                    }\n                }\n                return message;\n            }\n        });\n    }\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        config.enableSimpleBroker(\"/topic\", \"/queue\");\n        config.setApplicationDestinationPrefixes(\"/app\");\n        config.setUserDestinationPrefix(\"/user\");\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<pre><code>@RestController\npublic class SSEController {\n\n    @GetMapping(value = \"/api/notifications/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n    @PreAuthorize(\"hasRole('USER')\")\n    public SseEmitter streamNotifications(Authentication auth) {\n        String userId = auth.getName();\n        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);\n\n        // Register user-specific SSE connection\n        notificationService.registerSSEConnection(userId, emitter);\n\n        emitter.onCompletion(() -&gt; notificationService.removeSSEConnection(userId));\n        emitter.onTimeout(() -&gt; notificationService.removeSSEConnection(userId));\n\n        return emitter;\n    }\n\n    // Send authenticated notifications\n    @PostMapping(\"/api/notifications/send\")\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public ResponseEntity&lt;?&gt; sendNotification(@RequestBody NotificationRequest request) {\n        notificationService.sendToUser(request.getUserId(), request.getMessage());\n        return ResponseEntity.ok().build();\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#webhooks","title":"Webhooks","text":"<pre><code>@RestController\npublic class WebhookController {\n\n    // Incoming webhook with signature verification\n    @PostMapping(\"/webhooks/payment/{provider}\")\n    public ResponseEntity&lt;String&gt; handlePaymentWebhook(\n            @PathVariable String provider,\n            @RequestBody String payload,\n            @RequestHeader(\"X-Signature\") String signature,\n            HttpServletRequest request) {\n\n        WebhookProvider webhookProvider = webhookProviderService.getProvider(provider);\n\n        if (!webhookProvider.verifySignature(payload, signature)) {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\"Invalid signature\");\n        }\n\n        paymentProcessor.processWebhookEvent(provider, payload);\n        return ResponseEntity.ok(\"Processed\");\n    }\n\n    // Outgoing webhook with OAuth2\n    @EventListener\n    public void sendWebhookNotification(OrderCompletedEvent event) {\n        String webhookUrl = customerService.getWebhookUrl(event.getCustomerId());\n        String accessToken = oAuth2TokenService.getClientToken(\"webhook-sender\");\n\n        WebClient.create()\n            .post()\n            .uri(webhookUrl)\n            .header(\"Authorization\", \"Bearer \" + accessToken)\n            .header(\"X-Event-Type\", \"order.completed\")\n            .bodyValue(event.getOrderData())\n            .retrieve()\n            .toBodilessEntity()\n            .subscribe(\n                success -&gt; log.info(\"Webhook sent successfully\"),\n                error -&gt; log.error(\"Webhook failed\", error)\n            );\n    }\n}\n</code></pre>"},{"location":"security/use-cases/#decision-framework","title":"\ud83c\udfaf Decision Framework","text":""},{"location":"security/use-cases/#choose-your-security-method","title":"Choose Your Security Method:","text":""},{"location":"security/use-cases/#1-start-with-these-questions","title":"1. Start with these questions:","text":"<ul> <li>Who are your users? (Internal employees \u2192 LDAP, External consumers \u2192 OAuth2)</li> <li>What's your scale? (Small \u2192 JDBC/Session, Large \u2192 JWT/OAuth2)</li> <li>What's your risk level? (High \u2192 mTLS, Medium \u2192 JWT, Low \u2192 API Keys)</li> <li>What protocols do you use? (REST \u2192 Any, gRPC \u2192 JWT/mTLS, WebSocket \u2192 JWT)</li> </ul>"},{"location":"security/use-cases/#2-common-combinations","title":"2. Common combinations:","text":"<ul> <li>Enterprise Web App: Session + LDAP</li> <li>Mobile App: JWT + OAuth2</li> <li>Microservices: JWT + mTLS</li> <li>Public API: API Keys + Rate Limiting</li> <li>B2B Integration: mTLS + Custom Tokens</li> <li>Government/Healthcare: SAML + mTLS</li> </ul>"},{"location":"security/use-cases/#3-migration-paths","title":"3. Migration paths:","text":"<ul> <li>Start Simple: JDBC \u2192 LDAP \u2192 OAuth2</li> <li>Scale Up: Session \u2192 JWT \u2192 OAuth2</li> <li>Secure Up: API Keys \u2192 JWT \u2192 mTLS</li> </ul> <p>\ud83d\udd0d Each authentication method in this project demonstrates these patterns with working code examples, theory, and integration guides!</p>"}]}